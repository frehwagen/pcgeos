/********************************************************************
 *
 *
 * PROJECT:     PC GEOS
 * MODULE:      C Cards header
 * FILE:        cards.goh
 *
 * AUTHOR:      Jon Witort
 *
 * REVISION HISTORY:
 * 	Name	Date			Description
 * 	----	----			-----------
 * 	Jon	9/90			Initial version
 *    NF    10/29/96    Converted to .goh file
 *                      - the FIXMEs are Nate's
 *    jfh	12/02			- fixed some of Nate's errors,
 *								- added default instance data
 *                      - Works well enough to power Freecell
 *                        but there may still be some problems
 *                      - set CardBack Selector default instance data
 *                        so that it works
 *
 *
 * DESCRIPTION:
 *
 *
 *******************************************************************/

#ifndef __CARDS_GOH
#define __CARDS_GOH

@deflib	cards

typedef struct {
    VMFileHandle NCBC_vmFile;
    word         NCBC_mapBlock;
    word         NCBC_cardWidth;
    word         NCBC_cardHeight;
} NotifyCardBackChange;

/********************************************************************
 * 	CardBackSelectorClass
 *******************************************************************/
@class CardBackSelectorClass, GenControlClass;

/*
 *      Returns list of item monikers.
 *
 *      PASS:           list - requesting list
 *                      item - item number
 *
 *      RETURN:         nothing
 */
@message void MSG_CBS_QUERY_CARD_BACK( optr list = cx:dx,
                                       word item = bp );

/*
 *      Brings up the cardback choosing box?
 *
 *      PASS:           card - which card back
 *                      item - item number
 *
 *      RETURN:         nothing
 */
@message void MSG_CBS_SET_CARD_BACK( word card = cx, word item = bp );

typedef struct {
    word TCBSCI_cardWidth;
    word TCBSCI_cardHeight;
} TempCBSCardInfo;

@vardata TempCBSCardInfo TEMP_CBS_CARD_INFO;

typedef WordFlags CardBackSelectorFeatures;
#define CBSF_CARD_BACK_LIST (0x01)

#define CARD_BACK_SELECTOR_DEFAULT_FEATURES (CardBackSelectorFeatures)

    @instance VMFileHandle  CBSI_vmFile;
    @instance VMBlockHandle CBSI_mapBlock;
    @instance word          CBSI_cardWidth;
    @instance word          CBSI_cardHeight;

	 @default GCI_output = TO_APP_TARGET;
	 @default GII_type = GIT_PROPERTIES;
	 @default GII_visibility = GIV_DIALOG;

@endc; /* CardBackSelectorClass */


/********************************************************************
 * 	Game Class
 *******************************************************************/

@class GameClass, VisContentClass, master;

/********************************************************************
 *              FATAL ERRORS
 *******************************************************************/
/*typedef enum {
    CANT_STOP_TIMER_WITH_NULL_HANDLE,
    CANT_DESTROY_GSTATE_WITH_NULL_HANDLE
} FatalErrors;

/********************************************************************
 *		DEFINES
 *******************************************************************/

typedef ByteEnum DragType;
/* outline dragging mode */
#define DRAG_OUTLINE 0x0
/* full card dragging mode */
#define DRAG_FULL    0x1

typedef ByteEnum UserMode;
#define BEGINNER_MODE     0x0
#define INTERMEDIATE_MODE 0x1
#define ADVANCED_MODE     0x2

#define EVEN_DATE_TIME_BUFFER_SIZE (((DATE_TIME_BUFFER_SIZE+1)/2)*2)

typedef ByteFlags GameAttrs;
/* set if game is visually closed */
#define GA_ICONIFIED        (0x08)
/*
 * set if a redeal has been
 * requested but unprocessed
 */
#define GA_REDEAL_REQUESTED (0x04)
/*
 * set if the card back design
 * should be the one designated
 * as the winner's back design
 */
#define GA_USE_WIN_BACK     (0x02)
/*
 * set if the user has won
 * since the last redeal
 */
#define GA_JUST_WON_A_GAME  (0x01)

/********************************************************************
 *		MESSAGES
 *******************************************************************/

/*
 * 	Returns the vm file containing the card bitmaps.
 *
 * 	PASS:           void
 *
 * 	RETURN:		VMFileHandle - vm file
 */
@message VMFileHandle MSG_GAME_GET_VM_FILE();

/*
 * 	This method is passed to the game object whenever
 * 	a deck flips a card.
 *
 * 	PASS:           nothing
 *
 * 	RETURN:         nothing
 */
@message void MSG_GAME_NOTIFY_CARD_FLIPPED();

/*
 * Set which card back to use.
 *
 * 	PASS:           cx = card back to use
 *
 * 	RETURN:         nothing
 */
@message void MSG_GAME_SET_WHICH_BACK( word back = cx );

/*
 * Get the card back that is being used.
 *
 * 	PASS:           nothing
 *
 * 	RETURN:         cx = card back being used
 */
@message word MSG_GAME_GET_WHICH_BACK();

/*
 * 	This method is called by a deck when the user double clicks
 * 	one of its cards. Game calls children asking
 * 	for a deck to accept the double-clicked card.
 *
 * 	PASS:		deck  = double clicked deck
 * 			attrs = attributes of the specific card that was
 * 				double clicked
 *
 * 	RETURN:		TRUE if card was taken, FALSE otherwise
 */
@message Boolean MSG_GAME_BROADCAST_DOUBLE_CLICK( optr deck = cx:dx,
                                                  word attrs = bp ) = carry;

/*
 * 	Provides the user with a summons in order to change the card
 * 	back design. This method is usually sent by a trigger in a
 * 	summons in the applications UI.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_CHANGE_BACK();

/*
 * 	Changes the backs of all the cards to match the one that the user
 * 	has chosen through the summons. This method is usually sent by a
 * 	list entry in the back selection summons.
 *
 * 	PASS:		cardBack = optr to selected list entry representing
 * 				   a card back
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_CHOOSE_BACK( optr cardBack = cx:dx );

/*
 * 	Creates the summons through which the user can select between
 * 	various card backs.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		optr = the summons
 */
@message optr MSG_GAME_CREATE_BACK_SUMMONS() = cx:dx;

/*
 * 	Broadcasts to children to hilite themselves if they would
 * 	be the destination if cards were dropped right now. This differs
 * 	from MSG_GAME_INVERT_ACCEPTORS in that the position of the drag is a
 * 	factor for this method (i.e., the cards must match AND the positions
 * 	must match).
 *
 * 	PASS:		deck  = dragging deck
 * 			attrs = attributes of the drop card
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_CHECK_HILITES( optr deck = cx:dx,
                                      word attrs = bp );

/*
 * 	Returns the larger of the passed value and the minimum allowed
 * 	score for the game. The default handler does nothing, so this
 * 	message should be subclassed if it is to be used.
 *
 * 	PASS:		score = score to check
 *
 * 	RETURN:		if score is not below minimum score,
 *                        then returns score
 * 			if score is below minimum score,
 *                        then returns minimum score
 */
@message word MSG_GAME_CHECK_MINIMUM_SCORE( word score = cx ) = cx;

/*
 * 	Collects all the game's cards and gives them to the game's
 *      hand object.
 *
 * 	PASS:		nothing
 *
 * 	NOTHING:	nothing
 */
@message void MSG_GAME_COLLECT_ALL_CARDS();

/*
 * 	This is the method sent to the game object when a card is selected.
 * 	The card tells the deck that it's been selected, and the deck asks
 * 	the game object for advice on what to do.
 *
 * 	PASS:		deck       = deck that was selected
 * 			cardNumber = # of card in composite that
 *                                   was selected
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_DECK_SELECTED( optr deck = cx:dx,
                                      word cardNumber = bp );

/*
 * 	Informs the game that the Undo operation is no longer valid,
 * 	and the user should be prohibited from doing it.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_DISABLE_UNDO();

/*
 * 	Informs the game that the Undo operation is now valid, and
 * 	that it may enable the user to select this option.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_ENABLE_UNDO();

/*
 * 	Sends a MSG_CARD_FADE_DRAW to every card in the fade array.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_DISTRIBUTE_FADE();

/*
 * 	Draws a generic blank card at the specified location. Uses both
 * 	GI_frameReg and GI_interiorReg to construct the blank card.
 *
 * 	PASS:		left,top - Position of blank card
 * 			gstate   - GStateHandle
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_DRAW_BLANK_CARD( word left = cx,
                                        word top = dx,
                                        GStateHandle gstate = bp );

/*
 * 	Draws a black-bordered white rectangle the size of a
 * 	card at the specified location.
 *
 * 	PASS:		left,top - Position of fake blank card
 * 			gstate   - GStateHandle
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_FAKE_BLANK_CARD( word left = cx,
                                        word top = dx,
                                        GStateHandle gstate = bp );

/*
 * 	Draws a card frame at the specified location. Uses
 * 	GI_frameReg to construct the frame.
 *
 * 	PASS:		left,top - Position of frame
 * 			gstate   - GStateHandle
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_DRAW_FRAME( word left = cx,
                                   word top = dx,
                                   GStateHandle gstate = bp );

/*
 * 	This method is called by the dragging deck when the user
 * 	has released the cards. Game calls children asking
 * 	for a deck to accept the dropped cards.
 *
 * 	PASS:		deck  = dragging (and dropping) deck
 * 			attrs = drop card attributes
 *
 * 	RETURN:		Carry set if dropped cards were taken by
 *                      another deck.
 */
@message Boolean MSG_GAME_DROPPING_DRAG_CARDS( optr deck = cx:dx,
                                               word attrs = bp ) = carry;

/*
 * 	Returns the information necessary to get at the bitmap currently
 * 	in use as the card back design.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		dword:
 *                      high word - vm block handle containing bitmap
 * 			low word - offset within block of bitmap
 */
@message dword MSG_GAME_GET_BACK_BITMAP() = cx:dx;

/*
 * 	Returns the drag type (i.e., either DRAG_OUTLINE or DRAG_FULL).
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		DragType
 */
@message DragType MSG_GAME_GET_DRAG_TYPE() = cl;

/*
 * 	Returns the information necessary to get at the bitmap for the
 * 	passed card type.
 *
 * 	PASS:		bp = card attributes
 *
 * 	RETURN:		dword:
 *                      high word - vm block handle containing bitmap
 * 			low word - offset within block of bitmap
 */
#define GFB_GET_VM_BLOCK(a) ((word)(a >> 16 ))
#define GFB_GET_OFFSET(a) ((word)(a))
@message dword MSG_GAME_GET_FACE_BITMAP( word attrs = bp) = cx:dx;

/*
 * 	Returns the UserMode that the game is currently under.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		UserMode
 */
@message UserMode MSG_GAME_GET_USER_MODE() = cl;

/*
 * 	Game is sent this method when a (the) hand object is selected.
 * 	The default action is to treat the hand like any other deck,
 * 	which probably won't be terribly accurate in most cases. This
 * 	handler will likely be widely subclassed.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_HAND_SELECTED();

/*
 * 	Asks all decks to hilite themselves if they would accept
 * 	the current drag based on the drop card (NOT on the current
 * 	position of the drag).
 *
 * 	PASS:		deck  = dragging deck
 * 			attrs = card attributes of the drop card
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_INVERT_ACCEPTORS( optr deck = cx:dx,
                                         word attrs = bp );

/*
 * 	Asks all decks to set their DA_WANTS_DRAG bit if they
 * 	would accept the current drag based on the drop card
 * 	(not on the current position of the drag)
 *
 * 	PASS:		deck  = dragging deck
 * 			attrs = card attributes of the drop card
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_MARK_ACCEPTORS( optr deck = cx:dx,
                                       word attrs = bp );

/*
 * 	This is the method that a deck calls when one of
 * 	its cards is selected. This method determines whether
 * 	a given card should be included in the drag or not,
 * 	depending on the deck's attributes. For example, in the
 * 	following scenario:
 *
 *
 * 			+--------------------+
 * 			!                    !
 * 			! 6 Hearts           !
 * 			!                    !
 * 			+--------------------+
 * 			!                    !
 * 			! 5 Clubs            !
 * 			!                    !
 * 			+--------------------+
 * 			!                    !
 * 			! 4 Diamonds         !
 * 			!                    !
 * 			+--------------------+
 * 			!                    !
 * 			! 3 Clubs            !
 * 			!                    !
 * 			!                    !
 * 			!                    !
 * 			!                    !
 * 			!                    !
 * 			!                    !
 * 			!                    !
 * 			!                    !
 * 			!                    !
 * 			+--------------------+
 *
 * 		if the 4 is selected, and we are playing klondike
 * 		under the easiest rules(BEGINNER_MODE), we want to drag
 * 		the 3 and the 4; we would make three calls to this method;
 * 		calls concering the 3 and 4 would indicate that the
 * 		cards should be dragged, whereas the 5 would be
 * 		rejected.
 *
 * PASS:        selected -
 *              highbyte = # of selected card
 *                ;(the 4 in the above example)
 * 		lowbyte = attrs of selected card
 *                ;(the 4 in the above example)
 *
 * 		query
 *              highbyte = # of query card
 * 		lowbyte = attrs of query card
 *
 * 		deckAttrs = deck attrs
 *
 * RETURN:	TRUE if accept
 * 		FALSE if no accept
 */
@message Boolean MSG_GAME_QUERY_DRAG_CARD( word selected = cx,
                                           word queryCard = dx,
                                           DeckAttrs deckAttrs = bp ) = carry;

/*
 * 	Returns a random number between 0 and the passed value.
 *
 * 	PASS:		randomMax = maximum random number to return
 *
 * 	RETURN:		random number
 *
 * 	This random number generator is not a very good one; it is sufficient
 * 	for a wide range of tasks requiring random numbers (it will work
 * 	fine for shuffling, etc.), but if either the "randomness" or the
 * 	distribution of the random numbers is crucial, you may want to look
 * 	elsewhere.
 */
@message word MSG_GAME_RANDOM( byte randomMax = dl) = dx;

/*
 * 	This method stores the passed OD of a deck in case we need to
 * 	communicate with the dragging deck for any reason (one case in
 * 	particular is the need to forward any MSG_META_EXPOSED's to this deck)
 *
 * 	PASS:		deck = dragging deck
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_REGISTER_DRAG( optr deck = cx:dx );

/*
 * 	Keeps track of the one (if any) deck that is currently
 * 	hilited.  Also issues a MSG_DECK_INVERT to this deck
 * 	if it is just now getting hilited (vs. having been hilited
 * 	for multiple calls already).  Also re-inverts the used-to-be
 * 	hlited deck (if any), to make it unhilited.
 *
 * 	PASS:		deck = hilited deck
 * 			       or NullOptr for no hilited deck
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_REGISTER_HILITED( optr deck = cx:dx );

/*
 * 	Seeds the game's random number generator
 *
 * 	PASS:		seed = seed for the random number
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SEED_RANDOM( word seed = dx );

/*
 * 	Sets the DragType that the game should play under
 *
 * 	PASS:		dragType = DragType
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SET_DRAG_TYPE( DragType dragType = cl );

/*
 * 	Sets the UserMode that the game should play under.
 *
 * 	PASS:		userMode = UserMode
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SET_USER_MODE( userMode userMode = cl );

/*
 * 	Gives the game object an opportunity to arrange its many objects
 * 	on the screen (usually at startup). This method is passed the width
 * 	and height of a card as rudimentary size units.
 *
 * 	PASS:		cardWidth,
 *                      cardHeight = x,y deck spacing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SETUP_GEOMETRY( word cardWidth = cx,
                                       word cardHeight = dx );

/*
 * 	Will read in the BitMap's of the cards.
 *
 * 	PASS:		gameClass = GameClass object (ds:si) FIXME
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_RESTORE_BITMAPS( ClassStruct * gameClass );


/*
 * 	Sets up various defaults and does assorted dirty work associated
 * 	with starting up a game.
 *			calls:	MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME
 *						MSG_GAME_SET_UP_SPREADS
 *						MSG_GAME_SET_DOWN_SPREADS
 *						MSG_GAME_SET_FONT_SIZE
 *						MSG_GAME_GET_VM_FILE
 *						MSG_GAME_SET_CARD_DIMENSIONS
 *						MSG_GAME_SETUP_GEOMETRY
 *						MSG_GAME_SEND_CARD_BACK_NOTIFICATION
 *
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SETUP_STUFF();

/*
 * 	Records the passed OD as the last deck to give cards to another
 * 	deck
 *
 * 	PASS:		deck = donor deck
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SET_DONOR( optr deck = cx:dx );

/*
 * 	Gives the game object an opportunity to arrange its many objects
 * 	on the screen (usually at startup). This method is passed the width
 * 	and height of a card as rudimentary size units.
 *
 * 	PASS:		cardWidth,cardHeight = width,height of a card
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SET_CARD_DIMENSIONS( word cardWidth = cx,
                                            word cardHeight = dx );

/*
 * 	Gives the game object an opportunity to set any spread info
 * 	concerning face down cards.
 *
 * 	PASS:		xSpread,
 *                      ySpread = x,y spreads for face down cards
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SET_DOWN_SPREADS( word xSpread = cx,
                                         word ySpread = dx );

/*
 * 	Gives the game object an opportunity to set any spread info
 * 	concerning face up cards.
 *
 * 	PASS:		xSpread,
 *                      ySpread = x,y spreads for face up cards
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SET_UP_SPREADS( word xSpread = cx,
                                       word ySpread = dx );

/*
 * 	Gives the game object an opportunity to set any text to the
 * 	passed size.
 *
 * 	PASS:		pointSize = new point size
 *
 * 	RETURN;		nothing
 */
@message void MSG_GAME_SET_FONT_SIZE( word pointSize = cx );

/*
 * 	Sets the initial and incremental fade masks to use while fade
 * 	drawing. Note that the initial mask is *NOT* the first mask
 * 	used when drawing; the mask is incremented before the first
 * 	draw, i.e., the first draw during a fade will use the
 * 	mask (initial + inremental).
 *
 * 	PASS:		incMask = incremental mask
 * 			initMask = initial mask
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SET_FADE_PARAMETERS( byte incMask = cl,
                                            byte initMask = dl );

/*
 * 	Takes care of any business involved with closing the
 *      game application.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SHUTDOWN();

/*
 * 	Gives the game a chance to unmark any decks that for some reason
 * 	were marked as acceptors of the current drag. Klondike uses this
 *      method to unmark any two's that may be marked as willing to accept
 *      aces, since aces onto twos are a special exception in klondike's
 *      rules.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_UNMARK_ACCEPTORS();

/*
 * 	Does the grunt work maintaining the fade array. Cards make requests
 * 	to be added to or removed from the array, and this handler fulfills
 * 	those requests and manages the timer and gstate associated with
 * 	card fading.
 *
 * 	PASS:		card = card making request
 * 			addOrRemove = PLEASE_ADD_ME_TO_THE_ARRAY if card
 *                                    wants its OD included in the array,
 * 			     PLEASE_REMOVE_ME_FROM_THE_ARRAY if card wants
 * 				its OD out of the array
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_UPDATE_FADE_ARRAY( optr card = cx:dx,
                                          word addOrRemove = bp );

/*
 * 	Updates the game's score internally and on screen
 *
 * 	PASS:		if score is to be zeroed:
 * 				score = change = 0
 * 			if score is to be set absolutely but not to 0:
 * 				score = value to set score to
 * 			if score is to be incremented or decremented:
 * 				score = 0,
 *                              change = amount to add to current score
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_UPDATE_SCORE( word score = cx,
                                     word change = dx );

/*
 * 	Clears out the game's fade array, sending MSG_CARD_CLEAR_FADING's
 * 	to each of the cards in the array before removing them.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_ZERO_FADE_ARRAY();

/*
 * 	Forces the Game object to send out a notification regarding
 * 	the bitmaps it's using as card designs
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_GAME_SEND_CARD_BACK_NOTIFICATION();

/*
 * 	Creates a memory block sufficient to restore the current game
 * 	whenm passed to MSG_GAME_RESTORE_STATE
 *
 * 	PASS:		nothing
 *
 * 	RETURN:         dword:
 *                      highword - mem block handle
 * 			lowword - bytes written so far (so subclassings know
 * 			     where to start writing)
 */
#define GSS_GET_MEM_BLOCK(a) ((MemHandle)(a >> 16))
#define GSS_GET_BYTES_WRITTEN(a) ((word)(a))
@message dword MSG_GAME_SAVE_STATE() = cx:dx;

/*
 * 	Restores a game to its previous state when passed a block
 * 	that was returned from MSG_GAME_SAVE_STATE
 *
 * 	PASS:		memBlock - mem block
 *
 * 	RETURN:		word - bytes read from block (so subclassings know
 * 			     where to start reading)
 */
@message word MSG_GAME_RESTORE_STATE( MemHandle memBlock = cx ) = dx;


/********************************************************************
 *		INSTANCE DATA
 *******************************************************************/

	 @instance DisplayType GI_displayScheme;

	 @instance GameAttrs GI_gameAttrs;

	 @instance DragType GI_dragType = DRAG_OUTLINE;

	 @instance UserMode GI_userMode = BEGINNER_MODE;

      /* OD to the object serving as the 'hand' */
	 @instance optr GI_hand;

      /* VisText object that holds the score */
	 @instance optr GI_scoreOutput;

      /* lptr.ChunkArrayHeader ;this array keeps the ODs
       * of any cards that should receive messages to fade in
       * when the time comes */
	 @instance ChunkHandle GI_fadeArray;

      /* OD of the deck that last gave cards to another
       * (used for undo) */
	 @instance optr GI_lastDonor;

      /* OD of the one deck that is currently hilited (more than
       * one may be hilited, but in the case that we need to
       * remember one in particular, the OD goes here. */
	 @instance optr GI_hilited;

      /* OD of the deck that owns cards currently being dragged (if any) */
	 @instance optr GI_dragger;

      /* the game score */
	 @instance word GI_score = 0;

      /* the score before the last score change */
	 @instance word GI_lastScore = 0;

      /* handle of the timer that sends messages to fade */
	 @instance TimerHandle GI_faderHandle;

      /* gstate to fade through */
	 @instance GStateHandle GI_gState;

    /*
     * 	The following two instance data slots control the visual effect of
     * 	fading. The first one, GI_initialFadeMask is the initial area mask
     * 	the card should store, adding to this the second value,
     * 	GI_incrementalFadeMask, each time it receives a method to update
     * 	the fade.
     *
     * 	Example 1:	Cards should fade in 25%, 50%, 75%, then 100%
     *
     * 	GI_initialFadeMask = SDM_0
     * 	GI_incrementalFadeMask = SDM_25 - SDM_0
     *
     * 	Example 2:	Cards shouldn't fade (i.e., 100% only)
     *
     * 	GI_initialFadeMask = SDM_100
     * 	GI_incrementalFadeMask = 0
     */

      /* this is the area mask the cards take when they initially
       * begin fading in */
	 @instance SystemDrawMask GI_initialFadeMask = SDM_0;

      /* this is the amount to add to
       * a card's fade mask to get
       * the new fade mask
       */
	 @instance byte GI_incrementalFadeMask = SDM_25 - SDM_0;

      /* indicates which of the card
       * back designs in the array
       * should be used
       */
	 @instance word GI_whichBack = 0;

      /* the region to be drawn as the card border */
	 @instance ChunkHandle GI_frameReg;

      /* the region to be drawn as the card's interior background */
	 @instance ChunkHandle GI_interiorReg;  

      /* vm file containing the card bitmaps */
	 @instance VMFileHandle GI_vmFile;

      /* stores the map block of the card bitmaps */
	 @instance VMBlockHandle GI_mapBlock;

      /* width of a full sized card */
	 @instance word GI_cardWidth;

      /* height of a full sized card */
	 @instance word GI_cardHeight;

	 @instance word GI_upSpreadX;
	 @instance word GI_upSpreadY;
	 @instance word GI_downSpreadX;
	 @instance word GI_downSpreadY;

      /* OD of any undo trigger */
	 @instance optr GI_undoTrigger;

      /* the seed to use when generating random numbers */
	 @instance word GI_randomSeed;

	 @default VCNI_attrs = @default | VCNA_SAME_WIDTH_AS_VIEW
											  | VCNA_SAME_HEIGHT_AS_VIEW;


@endc; /* GameClass */



/********************************************************************
 * 	        Card Class (must come before DeckClass)
 *******************************************************************/

@class  CardClass, VisClass, master;

/********************************************************************
 *		DEFINES
 *******************************************************************/

typedef WordFlags CardRank;
#define CR_NONE  0x0
#define CR_ACE   0x1
#define CR_TWO   0x2
#define CR_THREE 0x3
#define CR_FOUR  0x4
#define CR_FIVE  0x5
#define CR_SIX   0x6
#define CR_SEVEN 0x7
#define CR_EIGHT 0x8
#define CR_NINE  0x9
#define CR_TEN   0xa
#define CR_JACK  0xb
#define CR_QUEEN 0xc
#define CR_KING  0xd
#define CR_WILD  0xf

typedef ByteEnum CardSuit;
/*  these forced assignments should */
#define CS_DIAMONDS 0x0
/*  NOT be changed, as they allow for */
#define CS_HEARTS   0x1
/*  optimizations in the code (in */
#define CS_CLUBS    0x2
/*
 *  particular, the high bit indicates
 *  blackness
 */
#define CS_SPADES   0x3

typedef WordFlags CardAttrs;
/* set if the card should draw inverted */
#define CA_INVERTED     (0x0400)
/*
 * set if the card's current bitmap is
 * monochrome
 */
#define CA_MONO_BITMAP  (0x0200)
/*
 * indicates whether the card's bitmap
 * pointer should be updated before
 * drawing
 */
#define CA_DIRTY        (0x0100)
/*
 * indicates whether this card is
 * currently fading (i.e., is not fully
 * faded in yet).
 */
#define CA_FADING       (0x0080)

/* the card's rank - CardRank*/
#define CA_RANK	(0x0040 | 0x0020 | 0x0010 | 0x0008)
#define CA_RANK_OFFSET	3

/* the card's suit - CardSuit*/
#define CA_SUIT	(0x0004 | 0x0002)
#define CA_SUIT_OFFSET	1

/* indicates whether the card is face up */
#define CA_FACE_UP      (0x0001)

/********************************************************************
 *		MESSAGES
 *******************************************************************/

/*
 * 	Returns the vm file containing the card bitmaps
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		vm file
 */
@message VMFileHandle MSG_CARD_GET_VM_FILE() = ax;

/*
 * 	Clears the CA_FADING bit from the card's attributes. The card will
 * 	no longer think it is fading, and can go on with normal life. This
 * 	message will NOT automatically remove the card from the fade array.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_CLEAR_FADING();

/*
 * 	Clears the CA_INVERTED bit from the card's attributes. If the card was
 * 	inverted, sends itself a MSG_CARD_INVERT
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_CLEAR_INVERTED();

/*
 * 	Clips the Vis bounds of a card. The arguments are passed with
 * 	the assumption that the card will be obscured by another visual
 * 	object (most likely another card), and that the upper left of the
 * 	obscuring object will be offset by cx,dx from the upper left of the
 * 	called card.
 *
 * 	PASS:		x = relative x-displacement of obscuring object
 * 			     from the left of this card
 * 			y = relative y-displacement of obscuring object
 * 			     from the top of this card
 *
 * 	RETURN:		nothing
 *
 * 	Note that if x and y are both non-zero, the bounds will not be
 * 	clipped, as the unobscured region of the card will still have
 * 	maximum width and height at some points.
 */
@message void MSG_CARD_CLIP_BOUNDS( word x = cx, word y = dx );

/*
 * 	This method fades the card in one more step, and sends a method
 * 	to the visual parent if it is done fading (mask = 100%).
 *
 * 	PASS:		gstate = gstate to draw through
 * 			mask = adjustment to the card's current area mask
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_FADE_DRAW( GStateHandle gstate = bp,
                                  byte mask = cl );

/*
 * 	Instructs the card that it should begin to fade in.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_FADE_REDRAW();

/*
 * 	Turns a card face up if it is face down, and vice-versa. Does
 * 	nothing visually.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_FLIP();

/*
 * 	Retrieves the card's CI_cardAttrs field in bp. See CardAttrs
 * 	below for the data structure.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		CardAttrs = CI_cardAttrs for the card
 * 			carry clear if successful  FIXME
 */
@message CardAttrs MSG_CARD_GET_ATTRIBUTES() = bp;

/*
 * 	Graphically inverts the screen in the card's vis bounds. If
 * 	the card is fading, the method is queued until it's finished.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_INVERT();

/*
 * 	Sets the CA_DIRTY bit in the card's CI_cardAttr field if
 * 	it is face down to indicate that its bitmap has changed.
 * 	This routine is used when the card back bitmap is changed,
 * 	and we want to redraw all the face down cards.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_MARK_DIRTY_IF_FACE_DOWN();

/*
 * 	Sets the card's width and height to full card size (dimensions
 * 	are stored in the game object
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_MAXIMIZE();

/*
 * 	Moves a card relative to its current position
 *
 * 	PASS:		deltaX = horizontal displacement
 * 			deltaY = vertical displacement
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_MOVE_RELATIVE( word deltaX = cx,
                                      word deltaY = dx );

/*
 * 	Card creates a gstate and draws itself.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_NORMAL_REDRAW();

/*
 * 	Signals whether the card is drawable (i.e., if VBA_DRAWABLE bit
 * 	is set.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		TRUE if card is drawable
 * 			FALSE if card is not drawable
 */
@message Boolean MSG_CARD_QUERY_DRAWABLE() = carry;

/*
 * 	Sets the card's attributes to the passed value, then
 * 	marks the card as dirty and sets its bitmap
 *
 * 	PASS:		attrs = CardAttrs
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_SET_ATTRIBUTES( CardAttrs attrs = bp );

/*
 * 	Points CI_bitmap to the right bitmap to draw for this card. The
 * 	card must have its rank, suit, and face up/down attributes set
 * 	before calling this method.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_SET_BITMAP();

/*
 * 	Set the VA_DRAWABLE vis bit for this card
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_SET_DRAWABLE();

/*
 * 	Clear the VA_DRAWABLE vis bit for this card
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		TRUE if nothing was done (already not drawable).
 *                      FALSE if set not drawable.
 */
@message Boolean MSG_CARD_SET_NOT_DRAWABLE() = carry;

/*
 * 	This method takes in a gstate, rotates it, then draws the card
 * 	through the gstate somewhere along the y-axis.
 *
 * 	PASS:		gstate = gstate to draw to
 * 			yPos = y coordinate to draw card at
 *                             (x assumed to be 0)
 * 			angle = # of degrees to rotate gstate before drawing
 *
 * 	RETURN:		bp = newly rotated gstate
 *
 * 	Since regions cannot be rotated (at least for release 1), the
 * 	blank card background is actually a fake; it is just a card sized
 * 	white rectangle with a black border.
 */
@message GStateHandle MSG_CARD_SPRAY_DRAW( GStateHandle gstate = bp,
                                           word yPos = cx,
                                           word angle = dx ) = bp;

/*
 * 	Turns the card face down (*NOT* visually). Clears the CA_FACE_UP
 * 	bit and sets the CA_DIRTY bit, then updates the card's bitmap.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_TURN_FACE_DOWN();

/*
 * 	Turns the card face up (*NOT* visually). Sets the CA_FACE_UP
 * 	bit and sets the CA_DIRTY bit, then updates the card's bitmap.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_TURN_FACE_UP();

/********************************************************************
 *		INSTANCE DATA
 *******************************************************************/

      /* The card's atrributes */
 	 @instance CardAttrs CI_cardAttrs =
					  ((CR_NINE << CA_RANK_OFFSET)
					  | (CS_HEARTS << CA_SUIT_OFFSET)
					  | CA_FACE_UP);

      /* Identifies the bitmap to be  drawn for this card */
	 @instance optr CI_bitmap = 0;
    @noreloc CI_bitmap;

      /* last area mask used when drawing this card (used in fading) */
	 @instance SystemDrawMask CI_areaMask = 0;

@endc; /* CardClass */



/* ------------------------------------------------------------------------------
 * 	Deck Class
 * ------------------------------------------------------------------------------*/

@class  DeckClass, VisCompClass, master;

/********************************************************************
 *		DEFINES
 *******************************************************************/

/*
 * 	If the user drops a drag set that doesn't get caught and is less
 * 	than the distance specified by the following 2 constants, then it
 * 	is considered somewhat of a mistake, and no fixup visual effects
 * 	are generated.
 */
#define MINIMUM_HORIZONTAL_DISPLACEMENT	(20)
#define MINIMUM_VERTICAL_DISPLACEMENT	(20)


/*
 * 	SuitAcceptanceCondition specify suit restrictions when checking
 * 	whether one card may be played onto another. For example, if
 * 	SAC_SAME_COLOR is in effect, then red cards may only be played
 * 	onto other red cards, and black cards may only be played onto
 * 	other blacks.
 */
typedef ByteEnum SuitAcceptanceCondition;
#define SAC_OPPOSITE_COLOR 0x0
#define SAC_SAME_COLOR     0x1
#define SAC_SAME_SUIT      0x2
#define SAC_ANY_SUIT       0x3

/*
 * 	RankAcceptanceCondition specify rank restrictions when checking
 * 	whether one card may be played onto another. For example, if
 * 	RAC_ONE_GREATER_RANK is in effect, then sevens may only be played
 * 	onto sixes, etc. If RAC_ABSOLUTE_RANK is in effect, then the deck
 * 	will only accept cards of a particular rank (i.e., not relative
 * 	to the deck's catch card).  An example is the foundations in Klondike,
 * 	which take only aces to begin with. An additional field is included in
 * 	CardAcceptanceConditions to specify which absolute rank we're
 *      talking about.
 */
typedef ByteEnum RankAcceptanceCondition;
#define RAC_ONE_LESS_RANK    0x0
#define RAC_ONE_GREATER_RANK 0x1
#define RAC_EQUAL_RANK       0x2
#define RAC_ABSOLUTE_RANK    0x3

/*
 * 	  CardAcceptanceConditions give a complete specification of
 *      restrictions in effect when checking whether one card may be
 *      played onto another.
 */
typedef WordFlags CardAcceptanceConditions;
/*
 * this bit should be set if the
 * deck will only accept drag
 * sets of one card only
 * (Klondike's foundations are
 * cases in point).
 */
#define CAC_SINGLE_CARD_ONLY	(0x0100)

#define CAC_SAC        (0x0080 | 0x0040)  /* SuitAcceptanceCondition */
#define CAC_SAC_OFFSET 6
#define CAC_RAC        (0x0020 | 0x0010)      /* RankAcceptanceCondition */
#define CAC_RAC_OFFSET 4
/* rank for RAC_ABSOLUTE_RANK */
#define CAC_RANK        (0x0008 | 0x0004 | 0x0002 | 0x0001)   /* CardRank */
#define CAC_RANK_OFFSET 0

/*
 * 	A ComparisonKit is a structure passed around when a drag set is being
 * 	checked for acceptance into other decks; it contains both the
 * 	attributes of the deck's catch card (CardAttrs CK_TOP_CARD) and what kind of
 * 	restrictions this deck places on transfers (CardAcceptanceConditions CK_CAC).
 */
typedef WordFlags ComparisonKit;
#define CK_TOP_CARD                       (0x8000 | 0x4000 | 0x2000 | \
                                         0x1000 | 0x0800 | 0x0400 | 0x0200)
#define CK_TOP_CARD_OFFSET                9
#define CK_CAC						        (0x0100 | 0x0080 | 0x0040 | \
													  0x0020 | 0x0010 | 0x0008 | \
													  0x0004 | 0x0002 | 0x0001)
#define CK_CAC_OFFSET 0

/*
 * 	DeckDragWhichCard gives information about which cards the deck should
 * 	drag when the user selects some card in its composite:
 *
 * 	DDWC_NONE:		Never drag cards (example is Klondike's hand)
 *
 * 	DDWC_TOP_ONLY:		If user selects top card, it is dragged; any
 * 				other card when selected will do nothing.
 *
 * 	DDWC_UNTIL_SELECTED:	Deck will drag all cards up to and including
 * 				the selected card.
 *
 * 	DDWC_TOP_OR_UPS:	If top card is selected, it is dragged; if
 * 				any other face up card is selected, all face
 * 				up cards are dragged (example is Klondike's
 * 				tableu elements in advanced mode).
 */
typedef ByteEnum DeckDragWhichCard;
#define DDWC_NONE           0x0
#define DDWC_TOP_ONLY       0x1
#define DDWC_UNTIL_SELECTED 0x2
#define DDWC_TOP_OR_UPS     0x3

typedef ByteFlags DeckAttrs;
/* 1 bit unused */
#define DA_INVERTED     (0x40)
#define DA_DDWC         (0x10 | 0x20)      /* DeckDragWhichCard */
#define DA_DDWC_OFFSET  4

/* Talon specific */
#define DA_JUST_UNCOVERED (0x08)

/*
 * Double clicking on a deck that
 * has this bit set will do nothing
 */
#define DA_IGNORE_DOUBLE_CLICKS (0x04)

/*
 * this bit, when set, instructs
 * the deck to not consider taking
 * a drag that has been double
 * clicked (as in klondike).
 */
#define DA_IGNORE_EXPRESS_DRAG (0x02)

/*
 * This bit indicates that the current
 * drag meets all the
 * CardAcceptanceConditions for this deck
 */
#define DA_WANTS_DRAG (0x01)

/********************************************************************
 *		MESSAGES
 *******************************************************************/

/*
 * 	Returns the vm file containing the card bitmaps.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		VMFileHandle - vm file
 */
@message VMFileHandle MSG_DECK_GET_VM_FILE() = ax;

/*
 * 	Returns the number of cards in this deck's composite.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		word = # of cards
 */
@message word MSG_DECK_GET_N_CARDS() = cx;

/*
 * 	Adds a card into the deck's visual tree as the first child.
 * 	Also moves the card to DI_topCardLeft, DI_topCardTop
 *
 * 	PASS:		card = card to add
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_ADD_CARD_FIRST( optr card = cx:dx );

/*
 * 	Called when one of the deck's cards receives a double click event.
 *
 * 	PASS:		card = # of child in composite that was
 *                             double-clicked (card = 0 for first child)
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_CARD_DOUBLE_CLICKED( word card = bp);

/*
 * 	Called when one of the decks cards is selected by the user. Deck
 * 	records the location of the mouse event and passes the event
 * 	up to the game object.
 *
 * 	PASS:		mouseX,
 *                      mouseY = x,y of mouse event
 * 			card = # of child in composite that was selected
 *                             (card = 0 for first child)
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_CARD_SELECTED( word mouseX = cx,
                                      word mouseY = cx,
                                      word card = bp );

/*
 * 	Marks any face down children as dirty, indicating that their
 * 	bitmap needs to be updated (in light of a back bitmap change
 * 	from the user).
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_CHANGE_KIDS_BACKS();

/*
 * 	Checks to see whether this deck's "catch bounds" overlap with
 * 	the passed deck's "drag bounds".
 *
 * 	PASS:		deck = dragging deck
 *
 * 	RETURN:		TRUE if drag bounds of the passed deck
 * 			overlap with the catch bounds of this deck.
 */
@message Boolean MSG_DECK_CHECK_DRAG_CAUGHT( optr deck = cx:dx ) = carry;

/*
 * 	Checks to see whether this deck would accept the drag if it
 * 	were to be dropped.
 *
 * 	PASS:		deck = dragging deck
 *
 * 	RETURN:		carry set if deck would accept cards
 */
@message Boolean MSG_DECK_CHECK_POTENTIAL_DROP( optr deck = cx:dx ) = carry;

/*
 * 	This method invalidates the portion of a deck's original
 * 	vis bounds that was clipped as a result of the deck
 * 	shinking.
 * 	(i.e., Let A = original deck bounds, B = new deck bounds:
 * 		this method invalidates A - B)
 *
 *
 * 	PASS:		gstate = gstate to invalidate through
 *
 * 		ALSO:
 * 			DI_initRight and DI_initBottom should contain the
 * 			right, bottom coordinates of the deck before
 * 			it shrunk.
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_CLEAN_AFTER_SHRINK( GStateHandle gstate = bp );

/*
 * 	Clips the visible bounds of the deck's nth card in preparation
 * 	for another card to be played onto it.
 *
 * 	PASS:		card = # of child in composite to clip
 *                             (card = 0 for first card)
 * 			xPos = x displacement of oncoming card
 * 			yPos = y displacement of oncoming card
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_CLIP_NTH_CARD( word card = bp,
                                      word xPos = cx,
                                      word yPos = cx );

/*
 * 	Sets deck's attribute instance data.
 *
 * 	PASS:		deckAttrs = Deck attributes
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_SET_ATTRS( DeckAttrs deckAttrs = cl );

/*
 * 	Called by one of the deck's face down cards when it is selected.
 *
 * 	PASS:		card = # of child in composite that was selected
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_DOWN_CARD_SELECTED( word card = bp );

/*
 * 	Once the game object has determined that a selected card is one that
 * 	can be dragged,  it sends this method to the deck. This method
 * 	starts the dragging process (grabbing the mouse, setting the
 * 	initial instance data for dragging, etc.)
 *
 * 	PASS:		card = # of children to drag
 * 			xPos,yPos = current mouse position
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_DRAGGABLE_CARD_SELECTED( word card = bp,
                                                word xPos = cx,
                                                word yPos = dx );

/*
 * 	Instructs the deck to either start a drag (if the passed card
 * 	is face up) or flip a card (if the passed card is face down).
 *
 * 	PASS:		card = # of child in composite that was selected
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_DRAG_OR_FLIP( word card = bp );

/*
 * 	Deck sends MSG_VIS_DRAW's to each of its drag cards
 *
 * 	PASS:		gstate = gstate to draw through
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_DRAW_DRAGS( GStateHandle gstate = bp );

/*
 * 	Draws an outline of the cards being dragged.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_DRAW_DRAG_OUTLINE();

/*
 * 	Deck draws itself the way it should look when it has no cards.
 *
 * 	PASS:		gstate = gstate to draw thorugh
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_DRAW_MARKER( GStateHandle gstate = bp );

/*
 * 	Draws the deck's cards in reverse order (i.e., last card is
 * 	drawn first). Since it is in general the case that a deck's
 * 	last card is its bottom-most card, drawing the cards in reverse
 * 	is what the user would expect to see if the bounds of the
 * 	cards overlap.
 *
 * 	PASS:		gstate
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_DRAW_REVERSE( GStateHandle gstate = bp );

/*
 * 	Tells deck to end the current drag. Deck informs the
 * 	game object that it is dropping the cards; the game object
 * 	seeks out possible destinations, and tells the deck whether
 * 	or not the transfer was successful (i.e., whether the cards
 * 	were taken elsewhere). Deck then cleans up the mess left
 * 	by dragging (both visually and internally).
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_DROP_DRAGS();

/*
 * 	Deck turns its top card over and sends it a MSG_CARD_FADE_REDRAW
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_CARD_FLIP_CARD();

/*
 * 	Moves dragged cards in accordance with a new MSG_META_PTR under
 * 	full card dragging.
 *
 * 	PASS:		xPos,yPos = new mouse coordinates
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_FULL_PTR( word xPos = cx, word yPos = dx );

/*
 * 	Retrieves the last set of cards that were given to another deck.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_RETRIEVE_CARDS();

/*
 * 	Returns the bounds within which a drag is considered "fair game"
 * 	for this deck to take.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		ax = left of catch boundary
 * 			bp = top of catch boundary
 * 			cx = right of catch boundary
 * 			dx = bottom of catch boundary
 */
@message void MSG_DECK_GET_CATCH_BOUNDS(); /* FIXME */

/*
 * 	A comparison kit contains the information needed to determine whether
 * 	a deck would accept a particular card during a drag. This method
 * 	returns this info.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		ComparisonKit
 */
@message ComparisonKit MSG_DECK_GET_COMPARISON_KIT() = bp;

/*
 * 	Add the passed card into the composite, and fade it in if it's
 * 	face up.
 *
 * 	PASS:		card = card to add
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_GET_DEALT( optr card = cx:dx );

/*
 * 	Returns the bounds of the deck's current drag
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		ax = left of drag boundary
 * 			bp = top of drag boundary
 * 			cx = right of drag boundary
 * 			dx = bottom of drag boundary
 */
@message void MSG_DECK_GET_DRAG_BOUNDS(); /* FIXME */

/*
 * 	Returns the attributes of the "drop card", the bottom card
 * 	of a drag set.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		bp = CardAttrs of the drop card
 */
@message CardAttrs MSG_DECK_GET_DROP_CARD_ATTRIBUTES() = bp;

/*
 * 	Returns the CardAttrs of the deck's nth card
 *
 * 	PASS:		card = # of child in composite to get attributes of
 *
 * 	RETURN:		CardAttrs = attributes of nth card
 * 			carry = clear if successful   FIXME
 */
@message CardAttrs MSG_DECK_GET_NTH_CARD_ATTRIBUTES( word card = bp ) = bp;

/*
 * 	Deck gives up all its cards to the passed deck. This is the same
 * 	as MSG_DECK_POP_ALL_CARDS, except that scoring is disabled throughout
 * 	the transfer.
 *
 * 	PASS:		deck = deck to give cards to
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_GET_RID_OF_CARDS( optr deck = cx:dx );

/*
 * 	This is the effect of an illegal drop in outline dragging
 * 	mode.  the outline of the drag region shinks to nothing
 * 	(implodes), then an outline grows to the size of the drag,
 * 	only relocated to where the drag began.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_IMPLODE_EXPLODE();

/*
 * 	Issues a WinInvalRect in the region where the drag first began.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_INVALIDATE_INIT();

/*
 * 	Deck visually inverts itself (or its top card, if any) if the
 * 	bit DA_WANTS_DRAG in DeckAttrs is set (i.e., it would accept
 * 	the drag if it were dropped upon).
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_INVERT_IF_ACCEPT();

/*
 * 	Deck will visually invert itself if it is marked as willing
 * 	to accept the current drag
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_INVERT();

/*
 * 	Ensures that the deck is not inverted
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_CLEAR_INVERTED();

/*
 * 	This method sets the DA_WANTS_DRAG bit in the DeckAttrs
 * 	iff the deck would accept the drag set from the passed dragger.
 *
 * 	PASS:		deck = dragging deck
 *
 * 	RETURN:		 nothing
 */
@message void MSG_DECK_MARK_IF_ACCEPT( optr deck = cx:dx );

/*
 * 	Prepares the deck to push a card into its composite.
 * 	The data in DI_topCardLeft and DI_topCardTop are changed
 * 	to reflect the new card coming, and the vis bounds of the
 * 	current	top card are clipped.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_MOVE_AND_CLIP();

/*
 * 	Adds offsets to the deck's information about the origin of
 * 	its top card (i.e., it is likely that another card is coming, and
 * 	it will be offset by some x,y offset).
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		dword
 *                      highword = offset added to DI_topCardLeft
 * 			lowword = offset added to DI_topCardTop
 */
#define DOTL_GET_LEFT(a) ((word)(a >> 16))
#define DOTL_GET_TOP(a) ((word)(a))
@message dword MSG_DECK_OFFSET_TOP_LEFT() = cx:dx;

/*
 * 	Moves dragged cards in accordance with a new MSG_META_PTR under
 * 	outline dragging.
 *
 * 	PASS:		xPos,yPos = new mouse coordinates
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_OUTLINE_PTR( word xPos = cx, word yPos = dx );

/*
 * 	Transfer all this deck's cards to another deck by popping them
 * 	off one by one and pushing them onto the other deck.
 *
 * 	PASS:		deck = deck to pop all cards to
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_POP_ALL_CARDS( optr deck = cx:dx );

/*
 * 	Removes the deck's top card from the deck's composite
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		if deck has children:
 * 				carry clear  FIXME
 * 				optr = popped card
 * 			else:
 * 				carry set  FIXME
 */
@message optr MSG_DECK_POP_CARD() = cx:dx;

/*
 * 	Pop a certain number of cards and push them into another deck's
 * 	composite.
 *
 * 	PASS:		deck = deck to give cards to.
 * 			numToPop = number of cards to give.
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_POP_N_CARDS( optr deck = cx:dx,
                                    word numToPop = bp );

/*
 * 	Pushes a card into the deck's composite, places it in the appropriate
 * 	spot on screen, and draws it in.
 *
 * 	PASS:		card = card to push
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_PUSH_CARD( optr card = cx:dx );

/*
 * 	This method IS the same as MSG_DECK_PUSH_CARD_NO_EFFECTS; it is here
 * 	so that it can be subclassed (see klondike's talon for ex.)
 */
@message void MSG_DECK_PUSH_CARD_NO_EFFECTS();

/*
 * 	Creates a gstate, then draws itself and its cards through it.
 * 
 * 	PASS:		nothing
 * 
 * 	RETURN:		nothing
 */
@message void MSG_DECK_REDRAW();

/*
 * 	Removes a card from the deck's composite
 *
 * 	PASS:		card =
 *                      if highword = 0, then lowword = # of child
 *                         to remove (0 for first)
 * 			else card = card to remove
 *
 * 	RETURN:		if a card was removed:
 * 				returns TRUE
 * 				^lcx:dx = removed card  FIXME
 *
 * 			if a card was not removed (couldn't be found):
 * 				returns FALSE
 */
@message Boolean MSG_DECK_REMOVE_NTH_CARD( optr card = cx:dx ) = carry;

/*
 * 	Fixes up the state of affairs (both visual and internal)
 * 	after the deck drops cards and no deck accepts them.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_REPAIR_FAILED_TRANSFER();

/*
 * 	Fixes up the state of affairs (both visual and internal)
 * 	after the deck drops cards and another deck accepts them.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_REPAIR_SUCCESSFUL_TRANSFER();

/*
 * 	Asks the game object to draw a blank card at a specified location
 *
 * 	PASS:		xPos,yPos = x,y to draw blank card
 * 			gstate = gstate to draw to
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_REQUEST_BLANK_CARD( word xPos = cx,
                                           word yPos = dx,
                                           GStateHandle gstate = bp );

/*
 * 	Asks the game object to draw a "fake" blank card at a specified
 * 	location. A fake blank card is just a black-bordered white rectangle
 * 	the size of a card.
 *
 * 	PASS:		xPos,yPos = x,y to draw blank card
 * 			gstate = gstate to draw to
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_REQUEST_FAKE_BLANK_CARD( word xPos = cx,
                                                word yPos = dx,
                                                GStateHandle gstate = bp );

/*
 * 	Asks the game object to draw a card frame at a specified location
 *
 * 	PASS:		xPos,yPos = x,y to draw card frame
 * 			gstate = gstate to draw to
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_REQUEST_FRAME( word xPos = cx,
                                      word yPos = dx,
                                      GStateHandle gstate = bp );

/*
 * 	Invalidates itself, transfers a specified number of cards to
 * 	a specified deck, and maximizes the top cards remaining after
 * 	the transfer.
 *
 * 	PASS:		deck = deck to give cards to.
 * 			numToGive = number of cards to give
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_RETURN_CARDS( optr deck = cx:dx,
                                     word numToGive = bp );

/*
 * 	Sets up the deck's instance data to drag a set of cards around.
 * 	Stores things like # of cards dragging, initial location of the drag
 * 	set, etc.
 *
 * 	PASS:		numCards = # of cards to drag
 * 			yPos,yPos = mouse location
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_SETUP_DRAG( word numCards = bp,
                                   word xPos = cx,
                                   word yPos = dx );

/*
 * 	Sets the # of points awarded/penalized for pushing,
 * 	popping, and turning cards in this deck
 *
 * 	PASS:		pointsPushed = points awarded for pushing a
 *                                     card to this deck
 * 			pointsPopped = points awarded for popping a
 *                                     card from this deck
 * 			pointsFlipped = points awarded for flipping
 *                                      a card over
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_SET_POINTS( word pointsPushed = cx,
                                   word pointsPopped = dx,
                                   word pointsFlipped = bp );

/*
 * 	Creates a card fan with the deck's cards.
 *
 * 	PASS:		gstate = gstate to draw through
 * 			radius = radius of fan
 * 			degrees = # degrees to rotate the gstate after
 *                                each card
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_SPRAY_CARDS( GStateHandle gstate = bp,
                                    word radius = cx,
                                    word degrees = dx );

/*
 * 	Widens (or shrinks) a deck's vis bounds by a certain amount (usually
 * 	due to the pushing or popping of a new card).
 *
 * 	PASS:		incWidth = incremental width
 * 			incHeight = incremental height
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_STRETCH_BOUNDS( word incWidth = cx,
                                       word incHeight = dx );

/*
 * 	Deck is instructed to take the drag set if the drag set has the correct
 * 	drop card and overlaps with this deck's catch bounds.
 *
 * 	PASS:		deck = dragging deck
 * 			cardAttrs = CardAttrs of the drop card of the drag set
 *
 * 	RETURN:		TRUE if the deck takes the drag set,
 * 			FALSE otherwise
 */
@message Boolean MSG_DECK_TAKE_CARDS_IF_OK( optr deck = cx:dx,
                                            CardAttrs cardAttrs = bp ) = carry;

/*
 * 	Deck is instructed to take the drag set if the drag set has the correct
 * 	drop card. Whether or not the drag set is within range of the deck's
 * 	catch bounds is NOT an issue.
 *
 * 	PASS:		deck = dragging deck
 * 			cardAttrs = CardAttrs of the drop card of the drag set
 *
 * 	RETURN:		carry is set if the deck takes the drag set,
 * 			carry is clear otherwise
 */
@message Boolean MSG_DECK_TAKE_DOUBLE_CLICK_IF_OK(
    optr deck = cx:dx,
    CardAttrs cardAttrs = bp ) = carry;

/*
 * 	Deck pushes the passed card if its current top card
 * 	is face down.
 * 	This is pretty much a method used exclusively for poker,
 * 	but it may have some general application.
 *
 * 	PASS:		card = card to be pushed
 *
 * 	RETURN:		TRUE if card was taken, FALSE otherwise
 */
@message Boolean MSG_DECK_TAKE_HIT_IF_OK( optr card = cx:dx ) = carry;

/*
 * 	Tests deck to see whether a set of dragged cards
 * 	would be accepted to the drag if it were dropped right
 * 	now (i.e., rank&suit are ok, and position is ok).
 *
 * 	PASS:		deck = dragging deck
 *
 * 	RETURN:		TRUE if the deck would accept the drag
 * 			set, FALSE otherwise
 */
@message Boolean MSG_DECK_TEST_ACCEPT_CARDS( optr deck = cx:dx ) = carry;

/*
 * 	Checks to see if the deck would accept the drag set from
 * 	the passed deck if it were dropped upon (i.e., see if the catch
 * 	card of this deck would take the drop card fom the drag deck).
 *
 * 	PASS:		deck = dragging deck
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_TEST_RIGHT_CARD( optr deck = cx:dx );

/*
 * 	Transfers all of a deck's cards to another deck. Relative
 * 	order of the cards is preserved.
 *
 * 	PASS:		deck = deck to give cards to.
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_TRANSFER_ALL_CARDS( optr deck = cx:dx );

/*
 * 	Transfers a deck's drag cards (if any) to another deck
 *
 * 	PASS:		deck = deck to give cards to.
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_TRANSFER_DRAGGED_CARDS( optr deck = cx:dx );

/*
 * 	Transfers a specified number of cards to another deck
 *
 * 	PASS:		deck = deck to give cards to
 * 			numCards = # of cards to give
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_TRANSFER_N_CARDS( optr deck = cx:dx,
                                         word numCards = bp );

/*
 * 	Updates the deck's drag instance data to reflect a new mouse
 * 	position.
 *
 * 	PASS:		xPos,yPos = new mouse position
 *
 *                      FIXME
 * 	RETURN:		cx,dx = left,top of drag set given new mouse position
 * 			ax,bp = left,top of drag set BEFORE new mouse position
 */
@message void MSG_DECK_UPDATE_DRAG( word xPos = cx, word yPos = dx );

/*
 * 	Sets the instance data indicating the position of the deck's
 * 	top card, and also reesizes the deck to make a tight fit
 * 	around its cards.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_UPDATE_TOPLEFT();

/*
 * 	Called when one of a deck's face up cards is selected.
 *
 * 	PASS:		card = # of child in composite that was selected
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_UP_CARD_SELECTED( word card = bp );

/*
 * 	Sets the instance data in the deck that determines the visual
 * 	offset between face down cards in that deck.
 *
 * 	PASS:		xSpread,ySpread = x,y spreads for face down cards
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_SET_DOWN_SPREADS( word xSpread = cx,
                                         word ySpread = dx );

/*
 * 	Sets the instance data in the deck that determines the visual
 * 	offset between face up cards in that deck.
 *
 * 	PASS:		xSpread,ySpread = x,y spreads for face up cards
 *
 * 	RETURN:		nothing
 */
@message void MSG_DECK_SET_UP_SPREADS( word xSpread = cx,
                                       word ySpread = dx );

/*
 * 	Tacks any info necessary to recreate the decks state onto the
 * 	end of the passed mem block, to be used on a subsequent
 * 	MSG_DECK_RESTORE_STATE
 *
 * 	PASS:		dataPtr - ptr to add data to (need to realloc space)
 *
 * 	RETURN:		dataPtr - updated to point after data
 */
@message void MSG_DECK_SAVE_STATE( void * dataPtr );

/*
 * 	Restores a deck to its previous state when passed a block
 * 	that was returned from MSG_GAME_SAVE_STATE
 *
 * 	PASS:		dataPtr - place to read saved info from
 *
 * 	RETURN:		dataPtr - updated to point past this decks
 * 				  info (in preparation for the next deck)
 */
@message void MSG_DECK_RESTORE_STATE( void * dataPtr );

/********************************************************************
 *		INSTANCE DATA
 *******************************************************************/

	@instance DeckAttrs DI_deckAttrs = ((DDWC_UNTIL_SELECTED << DA_DDWC_OFFSET)
													| DA_IGNORE_EXPRESS_DRAG);

          /* color of deck's marker */
	@instance Color DI_markerColor = C_LIGHT_BLUE;
	@instance SystemDrawMask DI_markerMask = SDM_50;

          /* # of points to add to score if a card is
           * added to this deck */
	@instance word DI_pushPoints = 0;

          /* # of points to add to score if a card is
           * removed to this deck */
	@instance word DI_popPoints = 0;

          /* # of points to add to score if a card
           * is flipped over in this deck. */
	@instance word DI_flipPoints = 0;

          /*
			  * CardAcceptanceConditions that should be applied when the
           * deck has no cards.
           */
	@instance CardAcceptanceConditions DI_noCardAC =
						(SAC_ANY_SUIT << CAC_SAC_OFFSET)
						| (RAC_ABSOLUTE_RANK << CAC_RAC_OFFSET)
						| CR_KING;

          /*
			  * CardAcceptanceConditions that should be applied when the
           * deck's top card is face down.
           */
	@instance CardAcceptanceConditions DI_downCardAC =
						(SAC_ANY_SUIT << CAC_SAC_OFFSET)
						| (RAC_ABSOLUTE_RANK << CAC_RAC_OFFSET)
						| CR_NONE;

          /*
			  * CardAcceptanceConditions that should be applied when the
           * deck's top card is face up.
           */
	@instance CardAcceptanceConditions DI_upCardAC =
						(SAC_OPPOSITE_COLOR << CAC_SAC_OFFSET)
						| (RAC_ONE_LESS_RANK << CAC_RAC_OFFSET);

          /* horizontal offset when placing a card
           * onto a face down card */
	@instance word DI_offsetFromDownCardX = 0;

          /* vertical offset when placing a card
           * onto a face down card
           *
           * 	This card is face down
           * 	+------------------+
           * 	|          ^       |
           * 	|        Y |       |
           * 	|          v       |
           * 	|     +------------------+
           * 	|     |                  |
           * 	|     |                  |
           * 	|<--->|                  |
           * 	|  X  |                  |
           * 	|     |                  |
           * 	|     |                  |
           * 	|     |                  |
           * 	|     |                  |
           */
	@instance word DI_offsetFromDownCardY = 5;


          /* horizontal offset when placing a card
           * onto a face up card */
	@instance word DI_offsetFromUpCardX = 0;
          /* vertical offset when placing a card
           * onto a face up card
           *
           * 	This card is face up
           * 	+------------------+
           * 	|          ^       |
           * 	|        Y |       |
           * 	|          v       |
           * 	|     +------------------+
           * 	|     |                  |
           * 	|     |                  |
           * 	|<--->|                  |
           * 	|  X  |                  |
           * 	|     |                  |
           * 	|     |                  |
           * 	|     |                  |
           * 	|     |                  |
           */
	@instance word DI_offsetFromUpCardY = 15;

          /* left bound of deck's current top card */
	@instance word DI_topCardLeft = 0;

          /* top bound of deck's current top card */
	@instance word DI_topCardTop = 0;

          /* # cards in the deck */
	@instance word DI_nCards = 0;

          /*
           * 	the following two instance data slots are for UNDO:
           *
           * 	DI_lastRecipient is the OD of the last deck that this deck
           * 			 gave cards to.
           *
           * 	DI_lastGift is the number of cards this deck gave last time.
           */
          /* OD of last deck that received cards from this deck. */
	@instance optr DI_lastRecipient = 0;

          /* number of cards last given to deck
           * pointed at by DI_lastRecipient */
	@instance word DI_lastGift = 0;

          /*
           * 	The rest of the instance data is only used when the deck
           * 	is dragging cards around
           */

          /* # of cards currently being dragged */
	@instance word DI_nDragCards = 0;

          /* distance from mouse pointer to the left
           * bound of a drag area */
	@instance word DI_dragOffsetX = 0;

			 /* distance from mouse pointer to the top
           * bound of a drag area */
	@instance word DI_dragOffsetY = 0;

          /* left coordinate used the last time the drag
           * was drawn */
	@instance word DI_prevLeft = 0;

          /* top coordinate used the last time the drag
           * was drawn */
	@instance word DI_prevTop = 0;

          /* initial left coordinate of the drag */
	@instance word DI_initLeft = 0;

          /* initial top coordinate of the drag */
	@instance word DI_initTop = 0;

	@instance word DI_initRight = 0;
	@instance word DI_initBottom = 0;

          /* width of the drag area */
	@instance word DI_dragWidth = 0;
          /* height of the drag area */
	@instance word DI_dragHeight = 0;

          /* graphics state for dragging */
	@instance GStateHandle DI_gState = 0;

	@default VCI_geoAttrs = @default | VCGA_CUSTOM_MANAGE_CHILDREN;

@endc; /* DeckClass */

/********************************************************************
 * 	        Hand Class
 *******************************************************************/

@class HandClass, DeckClass;

/********************************************************************
 *		MESSAGES
 *******************************************************************/

/*
 * 	Exchanges the attributes (which effectively switches the cards) of
 * 	the mth and nth cards in the deck's composite.
 *
 * 	PASS:		card1, card2 = #'s of cards in composite to
 *                                     switch attributes
 *
 * 	RETURN:		nothing
 */
@message void MSG_HAND_EXCHANGE_CHILDREN( word card1 = cx, word card2 = dx );

/*
 * 	Creates a full set of 52 cards and adds them to tthe hand's composite.
 * 	This method can be sent multiple times if multiple decks are required.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_HAND_MAKE_FULL_HAND();

/*
 * 	Shuffles the order of the cards within the hand.
 *
 * 	PASS:		nothing
 *
 * 	RETURN:		nothing
 */
@message void MSG_HAND_SHUFFLE();

/********************************************************************
 *		INSTANCE DATA
 *******************************************************************/

	@default DI_deckAttrs = ((DDWC_NONE << DA_DDWC_OFFSET)
									 | DA_IGNORE_DOUBLE_CLICKS);
	@default DI_markerColor = C_YELLOW;
	@default DI_markerMask = SDM_100;
	@default DI_noCardAC =
						(SAC_ANY_SUIT << CAC_SAC_OFFSET)
						| (RAC_ABSOLUTE_RANK << CAC_RAC_OFFSET)
						| CR_NONE;

	@default DI_downCardAC =
						(SAC_ANY_SUIT << CAC_SAC_OFFSET)
						| (RAC_ABSOLUTE_RANK << CAC_RAC_OFFSET)
						| CR_NONE;

	@default DI_upCardAC =
						(SAC_ANY_SUIT << CAC_SAC_OFFSET)
						| (RAC_ABSOLUTE_RANK << CAC_RAC_OFFSET)
						| CR_NONE;

@endc; /* HandClass */



/********************************************************************
 * 	        CardListEntry Class
 *******************************************************************/

void VisSendToChildrenWithTest( void );
void WriteNum( void );
void WriteTime( void );
void ScoreToTextObject( void );

#ifdef __HIGHC__
pragma Alias(VisSendToChildrenWithTest, "VISSENDTOCHILDRENWITHTEST");
pragma Alias(WriteNum, "WRITENUM");
pragma Alias(WriteTime, "WRITETIME");
pragma Alias(ScoreToTextObject, "SCORETOTEXTOBJECT");
#endif

@endlib

#endif

