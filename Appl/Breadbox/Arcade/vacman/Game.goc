/***********************************************************************
 *
 * PROJECT:   VacMan
 * MODULE:    GenProcess class stuff
 * FILE:      game.goc
 *
 * AUTHOR:    
 *
 * REVISION HISTORY:
 *  Date        Name                Description
 *  ----        ----                -----------
 *  11/28/00    DC                  got rid of wav file usage
 *	 jfh			1/3/00					re-write - changing Ed's graphics code
 *
 ************************************************************************/
/**********************************************************************
 * Includes                                                           *
 **********************************************************************/

@include <stdapp.goh>
@include <game.goh>

#include <Ansi/stdlib.h>
#include <Ansi/string.h>
#include <graphics.h>
#include <gstring.h>
#include <initfile.h>
#include <sound.h>

@include "global.goh"
@include "extern.goh"

@classdecl VacManProcessClass, neverSaved;
@classdecl VacContentClass;
@classdecl VacApplicationClass;

#define DIR_UP 0
#define DIR_DOWN 1
#define DIR_LEFT 2
#define DIR_RIGHT 3
#define DIR_NONE 4

VMFileHandle g_VMVAC = 0;
Sprite g_sprites[MAX_SPRITES];
sword g_vacmanX, g_vacmanY;
word g_dustCount, g_bunnyCount, g_gameScore, g_bunnyLeft, g_gameLives, g_level = 1;
word g_vacGameStatus = STATUS_NO_GAME;
byte g_keyTable[4] = {0, 0, 0, 0};
byte g_keyPressedTable[4] = {0, 0, 0, 0};
word g_lastDirection, g_newDirection, g_bunniesEaten;
byte g_curFrame = 0, g_bunnyRelease;
word g_cheat = 0, g_cheatIndex = 0;
word g_controlMethod = MOVE_MANUAL;
word g_sound = SOUND_SYSTEM;
word g_difficultyLevel = SPEED_SLOW;
Boolean g_moveThisFrame;
Boolean g_wasPaused = FALSE;
Boolean g_vacCaught;
Boolean g_bunCaught[4];
Boolean g_showCloud;
char *g_curBoard;

/* sounds */
MemHandle       powerUp, lose, eatPellet, ateBunny, caught = NullHandle;
const word powerUpBuf[] = {
	SSE_CHANGE,             0, IP_TRUMPET, IT_STANDARD_TABLE,
	SSE_CHANGE,             1, IP_DRAWBAR_ORGAN, IT_STANDARD_TABLE,
	SSE_GENERAL,            GE_SET_PRIORITY, SP_GAME,
	SSE_VOICE_ON,           0, HIGH_E, DYNAMIC_FFF,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           1, HIGH_E, DYNAMIC_FFF,
	SSDTT_TICKS,            5,
	SSE_VOICE_ON,           0, HIGH_D, DYNAMIC_FFF,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           1, HIGH_D, DYNAMIC_FFF,
	SSDTT_TICKS,            5,
	SSE_VOICE_ON,           0, HIGH_E, DYNAMIC_FFF,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           1, HIGH_E, DYNAMIC_FFF,
	SSDTT_TICKS,            5,
	SSE_VOICE_ON,           0, HIGH_G, DYNAMIC_FFFF,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           1, HIGH_G, DYNAMIC_FFFF,
	SSDTT_TICKS,            5,
	SSE_VOICE_OFF,          1,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            10,
	SSE_GENERAL,            GE_END_OF_SONG};

const word eatPelletBuf[] = {
	SSE_CHANGE,             0, IP_FX_CRYSTAL, IT_STANDARD_TABLE,
	SSE_CHANGE,             1, IP_FX_SCI_FI, IT_STANDARD_TABLE,
	SSE_GENERAL,            GE_SET_PRIORITY, SP_GAME,
	SSE_VOICE_ON,           0, HIGH_D, DYNAMIC_FFF,
	SSDTT_TICKS,            5,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_FFF,
	SSDTT_TICKS,            5,
	SSE_VOICE_OFF,          1,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            10,
	SSE_GENERAL,            GE_END_OF_SONG};

//const word loseBuf[] = {
const word caughtBuf[] = {
	SSE_CHANGE,             0, IP_CHOIR_AAHS, IT_STANDARD_TABLE,
	SSE_CHANGE,             1, IP_VOICE_OOHS, IT_STANDARD_TABLE,
	SSE_GENERAL,            GE_SET_PRIORITY, SP_GAME,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_FF,
	SSDTT_TICKS,            5,
	SSE_VOICE_ON,           1, LOW_E, DYNAMIC_FFFF,
	SSDTT_TICKS,            20,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_FFFF,
	SSDTT_TICKS,            5,
	SSE_VOICE_ON,           1, LOW_C, DYNAMIC_FF,
	SSDTT_TICKS,            40,
	SSE_VOICE_OFF,          1,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            10,
	SSE_GENERAL,            GE_END_OF_SONG};

const word loseBuf[] = {     /* from blackjack lose sound */
	SSE_CHANGE,             0, IP_ACOUSTIC_GRAND_PIANO, IT_STANDARD_TABLE,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_F, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D_b, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_GENERAL,            GE_END_OF_SONG};

/*const word caughtBuf[] = {
	SSE_CHANGE,             0, IP_FX_CRYSTAL, IT_STANDARD_TABLE,
	SSE_CHANGE,             1, IP_FX_SCI_FI, IT_STANDARD_TABLE,
	SSE_GENERAL,            GE_SET_PRIORITY, SP_GAME,
	SSE_VOICE_ON,           0, MIDDLE_C, DYNAMIC_FFF,
	SSDTT_TICKS,            5,
	SSE_VOICE_ON,           1, MIDDLE_C, DYNAMIC_FFFF,
	SSDTT_TICKS,            20,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_FFFF,
	SSDTT_TICKS,            5,
	SSE_VOICE_ON,           1, LOW_E, DYNAMIC_FFF,
	SSDTT_TICKS,            10,
	SSE_VOICE_OFF,          1,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            10,
	SSE_GENERAL,            GE_END_OF_SONG};
*/
const word ateBunnyBuf[] = {
	SSE_CHANGE,             0, IP_GUNSHOT, IT_STANDARD_TABLE,
	SSE_CHANGE,             1, IP_BREATH_NOISE, IT_STANDARD_TABLE,
	SSE_CHANGE,             2, IP_SEASHORE, IT_STANDARD_TABLE,
	SSE_CHANGE,             3, IP_HAND_CLAP, IT_STANDARD_TABLE,
	SSE_GENERAL,            GE_SET_PRIORITY, SP_GAME,
	SSE_VOICE_ON,           3, FR_HAND_CLAP, DYNAMIC_FFF,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_FFFF,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           1, LOW_D, DYNAMIC_FF,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           2, HIGH_D, DYNAMIC_F,
	SSDTT_TICKS,            2,
	SSE_VOICE_ON,           0, MIDDLE_E, DYNAMIC_FFF,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           1, HIGH_E, DYNAMIC_FFF,
	SSDTT_TICKS,            3,
	SSE_VOICE_ON,           0, HIGH_G, DYNAMIC_FFFF,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           3, FR_HAND_CLAP, DYNAMIC_FFFF,
	SSDTT_TICKS,            5,
	SSE_VOICE_OFF,          3,
	SSE_VOICE_OFF,          2,
	SSE_VOICE_OFF,          1,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            10,
	SSE_GENERAL,            GE_END_OF_SONG};


/* some prototypes */
void MoveVac(word whichWay);
Boolean CheckBarrier(word whichWay, char* theBoard);
Boolean BunnyCollide(word y, word x, word curbunny);
void UpdateLastPos(word curSprite);
void VacPlaySound(MemHandle soundHandle);

/**********************************************************************
 * Methods                                                            *
 **********************************************************************/
/***********************************************************************
 *      MSG_GEN_PROCESS_OPEN_APPLICATION for VacManProcessClass
 ***********************************************************************
 * SYNOPSIS:        called by app startup
 * PARAMETERS:   
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:    
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  dc	12/2/00	added in a VM file to hold the options...I don't 
 *				like using the .ini file for this
 *
 ***********************************************************************/
@method VacManProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{

	word 				curSprite;
	char                    fileName[] = "VacManOpt";
	VMBlockHandle		MapBlock;
	MemHandle			MBHandle;
	MemHandle			*MBHandlePtr = &MBHandle;
	VacOptBlockHeader		*VOBH_ptr;
	Boolean		initError, tips;


	@callsuper();
	@call application::MSG_GEN_APPLICATION_INSTALL_TOKEN();

	/* check for quick tips */
	initError = InitFileReadBoolean("VacMan", "showTips", &tips);
	if (initError) tips = TRUE;
	if (tips) {
		 @send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
														 SHOW_ON_STARTUP, TRUE);
		 @send QTipsDialogBox::MSG_GEN_INTERACTION_INITIATE();
	 } else
		 @send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
														 SHOW_ON_STARTUP, FALSE);

	FileSetCurrentPath(SP_USER_DATA, "GAME");

	/* Open the VacMan Options file */
	g_VMVAC = VMOpen(fileName, 0, VMO_CREATE, 0);

	/* get the map block and create if not there (one time only) */
	MapBlock = VMGetMapBlock(g_VMVAC);
	if (MapBlock == NULL)
	 {
		MapBlock = VMAllocLMem(g_VMVAC,
					    LMEM_TYPE_GENERAL,
					    sizeof(VacOptBlockHeader));
		VMSetMapBlock(g_VMVAC, MapBlock);

		VMLock(g_VMVAC, MapBlock, MBHandlePtr);
		VOBH_ptr = MemDeref(MBHandle);
		VOBH_ptr->VOBH_difficulty = g_difficultyLevel;
		VOBH_ptr->VOBH_sound = g_sound;
		VOBH_ptr->VOBH_movement = g_controlMethod;
		VMDirty(MBHandle);
		VMUnlock(MBHandle);
	 }
	VMLock(g_VMVAC, MapBlock, MBHandlePtr);
	VOBH_ptr = MemDeref(MBHandle);
	g_difficultyLevel = VOBH_ptr->VOBH_difficulty;
	g_controlMethod = VOBH_ptr->VOBH_movement;
	g_sound = VOBH_ptr->VOBH_sound;
	VMUnlock(MBHandle);

	@send Difficulty::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(g_difficultyLevel, FALSE);
	@send ControlGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(g_controlMethod, FALSE);
	@send SoundGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(g_sound, FALSE);

  /* this stays locked the entire time the app is open */
  MemLock(OptrToHandle(@CurrentBoard));
  g_curBoard = LMemDeref(@CurrentBoard);

  g_sprites[0].frames[0] = @Jvac1lBitmap;
  g_sprites[0].frames[1] = @Jvac2lBitmap;
  g_sprites[0].frames[2] = @Jvac3lBitmap;
  g_sprites[0].frames[3] = @Jvac1rBitmap;
  g_sprites[0].frames[4] = @Jvac2rBitmap;
  g_sprites[0].frames[5] = @Jvac3rBitmap;
  g_sprites[0].frames[6] = @Jvac1uBitmap;
  g_sprites[0].frames[7] = @Jvac2uBitmap;
  g_sprites[0].frames[8] = @Jvac3uBitmap;
  g_sprites[0].frames[9] = @Jvac1dBitmap;
  g_sprites[0].frames[10] = @Jvac2dBitmap;
  g_sprites[0].frames[11] = @Jvac3dBitmap;
  g_sprites[0].numframes = 12;

  for (curSprite = 1; curSprite <= MAX_SPRITES-1; curSprite++) {
	 g_sprites[curSprite].state = SPRITE_STATE_NORMAL;
    g_sprites[curSprite].state_timer = 0;
    g_sprites[curSprite].direction = SPRITE_DIRECTION_SEEK;
	 g_sprites[curSprite].frames[0] = @JbunBitmap;
	 g_sprites[curSprite].frames[1] = 0;
    g_sprites[curSprite].frames[2] = 0;
	 g_sprites[curSprite].curframe = 0;
    g_sprites[curSprite].numframes = 1;
  }


  /* put sounds in memory */
  SoundAllocMusic(powerUpBuf, 2, &powerUp);
  SoundAllocMusic(eatPelletBuf, 2, &eatPellet);
  SoundAllocMusic(loseBuf, 2, &lose);
  SoundAllocMusic(ateBunnyBuf, 4, &ateBunny);
  SoundAllocMusic(caughtBuf, 2, &caught);

}

/***********************************************************************
 *      MSG_GEN_PROCESS_CLOSE_APPLICATION for VacManProcessClass
 ***********************************************************************
 * SYNOPSIS:        called by app shutdown
 * PARAMETERS:   
 *
 * SIDE EFFECTS:
 *
 *
 * STRATEGY:    
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacManProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
 Boolean tips;


  @call self::MSG_VACMAN_SAVE_OPTIONS();

  MemUnlock(OptrToHandle(@CurrentBoard));
  /* to clean things up */
  if (g_vacGameStatus != STATUS_NO_GAME)
     @call VacGameContent::MSG_GAME_END_GAME();

  g_vacGameStatus = STATUS_NO_GAME;
  
  SoundStopMusic(powerUp);
  SoundFreeMusic(powerUp);
  SoundStopMusic(eatPellet);
  SoundFreeMusic(eatPellet);
  SoundStopMusic(lose);
  SoundFreeMusic(lose);
  SoundStopMusic(ateBunny);
  SoundFreeMusic(ateBunny);
  SoundStopMusic(caught);
  SoundFreeMusic(caught);

  VMClose(g_VMVAC, FALSE);

  /* set the quick tips if not default */
  tips = @call ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(SHOW_ON_STARTUP);
  InitFileWriteBoolean("VacMan", "showTips", tips);

  return(@callsuper());
}

/***********************************************************************
 *      MSG_VACMAN_SAVE_OPTIONS for VacManProcessClass
 ***********************************************************************
 * SYNOPSIS:        used to save options to the datafile 
 * PARAMETERS:   void
 *
 * SIDE EFFECTS:    saved options will be saved on startup
 *
 * STRATEGY:    changed from saving to .ini file to .dat file
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  DC	12/2		initial
 *
 ***********************************************************************/
@method VacManProcessClass, MSG_VACMAN_SAVE_OPTIONS
{
	VMBlockHandle		MapBlock;
	MemHandle			MBHandle;
	MemHandle			*MBHandlePtr = &MBHandle;
	VacOptBlockHeader		*VOBH_ptr;

	MapBlock = VMGetMapBlock(g_VMVAC);
	VMLock(g_VMVAC, MapBlock, MBHandlePtr);
	VOBH_ptr = MemDeref(MBHandle);
	VOBH_ptr->VOBH_difficulty = g_difficultyLevel;
	VOBH_ptr->VOBH_movement = g_controlMethod;
	VOBH_ptr->VOBH_sound = g_sound;
	VMDirty(MBHandle);
	VMUnlock(MBHandle);
}

/***********************************************************************
 *      MSG_SOUND_CHANGED for VacManProcessClass
 ***********************************************************************
 * SYNOPSIS:    takes sound selection and assigns to 
 *      global var of g_sound, called by choice made in Options menu
 * PARAMETERS:   void
 *
 * SIDE EFFECTS:  
 *
 * STRATEGY:    turns sound on or off, used to have FM sound, but yanked that
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacManProcessClass, MSG_SOUND_CHANGED
{
  g_sound = selection;
}

/***********************************************************************
 *      MSG_DIFFICULTY_CHANGED for VacManProcessClass
 ***********************************************************************
 * SYNOPSIS:        used to take difficulty selection, called by choice 
 *              made in Options menu
 * PARAMETERS:   void
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:   
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacManProcessClass, MSG_DIFFICULTY_CHANGED
{

  g_difficultyLevel = selection;
}

/***********************************************************************
 *      MSG_CONTROLS_CHANGED for VacManProcessClass
 ***********************************************************************
 * SYNOPSIS:        used to take controls selection, called by choice 
 *              made in Options menu
 * PARAMETERS:   void
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:   
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacManProcessClass, MSG_CONTROLS_CHANGED
{
  g_controlMethod = selection;
}

/***********************************************************************
 *      EraseCloud
 ***********************************************************************
 * SYNOPSIS:      called by VIS_DRAW method
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  jfh     1/9/01
 *
 ***********************************************************************/
void EraseCloud(GStateHandle gstate)
{
 word		x,y;


  GrSetAreaMaskSys(gstate, SDM_100);
	 for (x = g_sprites[0].x - 1; x <= g_sprites[0].x + 1; x++) {
		for (y = g_sprites[0].y - 1; y <= g_sprites[0].y + 1; y++) {
		  if (g_curBoard[y * LEVEL_WIDTH + x] == '*') {
			 GrSetAreaColor(gstate, CF_INDEX, C_BLUE, 0, 0);
			 GrFillRect(gstate, x*SQUARE, y*SQUARE,
						 x*SQUARE+SQUARE, y*SQUARE+SQUARE);
			 }
		  else {
          /* draw the bkgnd, then ... */
			 GrSetAreaColor(gstate, CF_INDEX, C_BLACK, 0, 0);
			 GrFillRect(gstate, x*SQUARE, y*SQUARE,
						 x*SQUARE+SQUARE, y*SQUARE+SQUARE);
			 if (g_curBoard[y * LEVEL_WIDTH + x] == '+') {
				GrSetAreaColor(gstate, CF_INDEX, C_LIGHT_GRAY, 0, 0);
				GrFillEllipse(gstate, x*SQUARE+8, y*SQUARE+8,
							 x*SQUARE+15, y*SQUARE+15);
				}
			 else if (g_curBoard[y * LEVEL_WIDTH + x] == '-') {
				GrSetAreaColor(gstate, CF_INDEX, C_WHITE, 0, 0);
				GrFillRect(gstate, x*SQUARE, y*SQUARE+5,
						 x*SQUARE+SQUARE, y*SQUARE+18);
				}
			 else if (g_curBoard[y * LEVEL_WIDTH + x] == 'N') {
				MemLock(OptrToHandle(@JbagBitmap));
				GrDrawBitmap(gstate, x*SQUARE+1, y*SQUARE+1,
							(Bitmap *)LMemDeref(@JbagBitmap), 0);
				MemUnlock(OptrToHandle(@JbagBitmap));
				}
			 }
		  }
		}
 }

 /***********************************************************************
 *      MSG_VIS_DRAW for VacContentClass
 ***********************************************************************
 * SYNOPSIS:   		draws the game board
 * PARAMETERS:       drawFlags, gstate
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacContentClass, MSG_VIS_DRAW
{
  char *board1;
  word x, y, boardOffset, frame, i;

  if (g_wasPaused) {
	 /*  'erase' the paused */
	 GrInvalRect(gstate, 170, 110, 290, 150);
	 g_wasPaused = FALSE;
    return;
	 }


  if (g_vacGameStatus == STATUS_NO_GAME) {
	 /* we've just opened the app or lost a game - draw a static board */

	 /* get the intro board */
	 MemLock(OptrToHandle(@Board1));
	 board1 = LMemDeref(@Board1);

	 /* draw the background */
	 GrSetAreaColor(gstate, CF_INDEX, C_BLACK, 0, 0);
	 GrFillRect(gstate, 0, 0, BOARD_WIDTH*SQUARE, BOARD_HEIGHT*SQUARE);

	 /* draw the board */
	 boardOffset = 0;
	 for (y = 0; y < BOARD_HEIGHT; y++) {
		for (x = 0; x < BOARD_WIDTH; x++) {
		  /* the walls */
		  if (board1[boardOffset] == '*') {
			 GrSetAreaColor(gstate, CF_INDEX, C_BLUE, 0, 0);
			 GrFillRect(gstate, x*SQUARE, y*SQUARE,
						 x*SQUARE+SQUARE, y*SQUARE+SQUARE);
			 }
		  /* the dust balls */
		  else if (board1[boardOffset] == '+') {
			 GrSetAreaColor(gstate, CF_INDEX, C_LIGHT_GRAY, 0, 0);
			 GrFillEllipse(gstate, x*SQUARE+8, y*SQUARE+8,
							 x*SQUARE+15, y*SQUARE+15);
			 }
		  /* the bunny door */
		  else if (board1[boardOffset] == '-') {
			 GrSetAreaColor(gstate, CF_INDEX, C_WHITE, 0, 0);
			 GrFillRect(gstate, x*SQUARE, y*SQUARE+5,
						 x*SQUARE+SQUARE, y*SQUARE+18);
			 }
		  /* the vacuum */
		  else if (board1[boardOffset] == 'V') {
			 MemLock(OptrToHandle(@Jvac1lBitmap));
			 GrDrawBitmap(gstate, x*SQUARE+1, y*SQUARE+1,
							(Bitmap *)LMemDeref(@Jvac1lBitmap), 0);
			 MemUnlock(OptrToHandle(@Jvac1lBitmap));
			 }
		  /* the power bag */
		  else if (board1[boardOffset] == 'N') {
			 MemLock(OptrToHandle(@JbagBitmap));
			 GrDrawBitmap(gstate, x*SQUARE+1, y*SQUARE+1,
							(Bitmap *)LMemDeref(@JbagBitmap), 0);
			 MemUnlock(OptrToHandle(@JbagBitmap));
			 }
		  /* the bunnies */
		  else if (board1[boardOffset] == 'B') {
			 MemLock(OptrToHandle(@JbunBitmap));
			 GrDrawBitmap(gstate, x*SQUARE+1, y*SQUARE+1,
							(Bitmap *)LMemDeref(@JbunBitmap), 0);
			 MemUnlock(OptrToHandle(@JbunBitmap));
			 }
		  boardOffset++;
		  } /* end of main x for */
		boardOffset++;
		}  /* end of main y for */
	 MemUnlock(OptrToHandle(@Board1));
	 }  /* end of static board */

  else {   /* playing or paused */
	 /* draw the static stuff */
	 boardOffset = 0;
	 for (y = 0; y < 13; y++) {
		for (x = 0; x < LEVEL_WIDTH-1; x++) {
		  if (g_curBoard[boardOffset] == '*') {
			 GrSetAreaColor(gstate, CF_INDEX, C_BLUE, 0, 0);
			 GrFillRect(gstate, x*SQUARE, y*SQUARE,
						 x*SQUARE+SQUARE, y*SQUARE+SQUARE);
			 }
		  else if (g_curBoard[boardOffset] == '+') {
			 GrSetAreaColor(gstate, CF_INDEX, C_LIGHT_GRAY, 0, 0);
			 GrFillEllipse(gstate, x*SQUARE+8, y*SQUARE+8,
							 x*SQUARE+15, y*SQUARE+15);
			 }
		  else if (g_curBoard[boardOffset] == '-') {
			 GrSetAreaColor(gstate, CF_INDEX, C_WHITE, 0, 0);
			 GrFillRect(gstate, x*SQUARE, y*SQUARE+5,
						 x*SQUARE+SQUARE, y*SQUARE+18);
			 }
		  else if (g_curBoard[boardOffset] == 'N') {
			 MemLock(OptrToHandle(@JbagBitmap));
			 GrDrawBitmap(gstate, x*SQUARE+1, y*SQUARE+1,
							(Bitmap *)LMemDeref(@JbagBitmap), 0);
			 MemUnlock(OptrToHandle(@JbagBitmap));
			 }
		  boardOffset++;
		  }
		boardOffset++;
		}

	 /* and the vacuum... */
	 /* where he is or just moved to... */
	 GrSetAreaColor(gstate, CF_INDEX, C_BLACK, 0, 0);
	 GrFillRect(gstate, g_vacmanX*SQUARE, g_vacmanY*SQUARE,
						 g_vacmanX*SQUARE+SQUARE, g_vacmanY*SQUARE+SQUARE);
	 /* which graphic to use? */
	 frame = g_sprites[0].curframe + g_sprites[0].direction;
	 MemLock(OptrToHandle(g_sprites[0].frames[frame]));
	 GrDrawBitmap(gstate, g_vacmanX*SQUARE+1, g_vacmanY*SQUARE+1,
						(Bitmap *)LMemDeref(g_sprites[0].frames[frame]), 0);
	 MemUnlock(OptrToHandle(g_sprites[0].frames[frame]));
	 /* and where he was - if he moved */
	 if ((g_sprites[0].lastx != g_sprites[0].x)
					  || (g_sprites[0].lasty != g_sprites[0].y)) {
		GrSetAreaColor(gstate, CF_INDEX, C_BLACK, 0, 0);
		GrFillRect(gstate, g_sprites[0].lastx*SQUARE, g_sprites[0].lasty*SQUARE,
						 g_sprites[0].lastx*SQUARE+SQUARE, g_sprites[0].lasty*SQUARE+SQUARE);
		}

	 /* and the bunnies */
	 for (i = 1; i <= g_bunnyCount; i++) {
		if ((g_sprites[i].lastx != g_sprites[i].x)
					  || (g_sprites[i].lasty != g_sprites[i].y)) {
		  /* if he was just caught and we reset last (below) - don't move again */
		  if (g_bunCaught[i-1]) {
			 g_bunCaught[i-1] = FALSE;
			 }
		  else {
			 /* OK - this guy moved */
			 MemLock(OptrToHandle(g_sprites[i].frames[0]));
			 GrDrawBitmap(gstate, g_sprites[i].x*SQUARE+1,
				  g_sprites[i].y*SQUARE+1,
				 (Bitmap *)LMemDeref(g_sprites[i].frames[0]), 0);
			 MemUnlock(OptrToHandle(g_sprites[i].frames[0]));
			 /* and put back whatever was where he was (dust ball or bag) */
			 GrSetAreaColor(gstate, CF_INDEX, C_BLACK, 0, 0);
			 GrFillRect(gstate, g_sprites[i].lastx*SQUARE, g_sprites[i].lasty*SQUARE,
						 g_sprites[i].lastx*SQUARE+SQUARE, g_sprites[i].lasty*SQUARE+SQUARE);
			 if (g_curBoard[(g_sprites[i].lasty - 1)*LEVEL_WIDTH + g_sprites[i].lastx] == '+') {
				GrSetAreaColor(gstate, CF_INDEX, C_LIGHT_GRAY, 0, 0);
				GrFillEllipse(gstate, g_sprites[i].lastx*SQUARE+8, g_sprites[i].lasty*SQUARE+8,
						 g_sprites[i].lastx*SQUARE+15, g_sprites[i].lasty*SQUARE+15);
				}
			 if (g_curBoard[(g_sprites[i].lasty - 1)*LEVEL_WIDTH + g_sprites[i].lastx] == 'N') {
				MemLock(OptrToHandle(@JbagBitmap));
				GrDrawBitmap(gstate, g_sprites[i].lastx*SQUARE+1, g_sprites[i].lasty*SQUARE+1,
							(Bitmap *)LMemDeref(@JbagBitmap), 0);
				MemUnlock(OptrToHandle(@JbagBitmap));
				}
			 /* or the vac */
			 if (((g_sprites[i].lasty - 1)*LEVEL_WIDTH + g_sprites[i].lastx) ==
						    ((g_vacmanY - 1)*LEVEL_WIDTH + g_vacmanX)) {
				frame = g_sprites[0].curframe + g_sprites[0].direction;
				MemLock(OptrToHandle(g_sprites[0].frames[frame]));
				GrDrawBitmap(gstate, g_vacmanX*SQUARE+1, g_vacmanY*SQUARE+1,
						(Bitmap *)LMemDeref(g_sprites[0].frames[frame]), 0);
				MemUnlock(OptrToHandle(g_sprites[0].frames[frame]));
				}
			 /* and the special case of if a bun was caught - we need to reset
			  * its last pos after we've moved it back to the hutch */
			 if (g_bunCaught[i-1]) {
				UpdateLastPos(i);
				}
			 }
		  }
		}  /* end of cycle thru bunnies for */

	 /* and a special case...
	  * If the vac was just caught by a bunny AND it is in its starting
	  * point, we need to redraw it now. */
	 if (g_vacCaught && (g_sprites[0].x == g_sprites[0].startx) &&
	           (g_sprites[0].y == g_sprites[0].starty)) {
		frame = g_sprites[0].curframe + g_sprites[0].direction;
		MemLock(OptrToHandle(g_sprites[0].frames[frame]));
		GrDrawBitmap(gstate, g_vacmanX*SQUARE+1, g_vacmanY*SQUARE+1,
						(Bitmap *)LMemDeref(g_sprites[0].frames[frame]), 0);
		MemUnlock(OptrToHandle(g_sprites[0].frames[frame]));
		}

	 /* do the dust cloud animation */
	 if (g_showCloud) {
	   g_showCloud = FALSE;
		MemLock(OptrToHandle(@Cloud1Moniker));
		GrSetAreaMaskSys(gstate, SDM_75);
		GrDrawBitmap(gstate, g_sprites[0].x*SQUARE-SQUARE+2,
									g_sprites[0].y*SQUARE-SQUARE+2,
									(Bitmap *)LMemDeref(@Cloud1Moniker), 0);
		TimerSleep(6);
		GrDrawBitmap(gstate, g_sprites[0].x*SQUARE-SQUARE+2,
									g_sprites[0].y*SQUARE-SQUARE+2,
									(Bitmap *)LMemDeref(@Cloud2Moniker), 0);
		TimerSleep(6);
		GrDrawBitmap(gstate, g_sprites[0].x*SQUARE-SQUARE+2,
									g_sprites[0].y*SQUARE-SQUARE+2,
									(Bitmap *)LMemDeref(@Cloud3Moniker), 0);
		TimerSleep(6);
		/* now I need to redraw the 9 squares to get rid of this
		 * first part of the animation */
		EraseCloud(gstate);
		/* now another part of the cloud */
		GrSetAreaMaskSys(gstate, SDM_75);
		GrDrawBitmap(gstate, g_sprites[0].x*SQUARE-SQUARE+2,
									g_sprites[0].y*SQUARE-SQUARE+2,
									(Bitmap *)LMemDeref(@Cloud3Moniker), 0);
		TimerSleep(12);
		EraseCloud(gstate);
		GrSetAreaMaskSys(gstate, SDM_50);
		GrDrawBitmap(gstate, g_sprites[0].x*SQUARE-SQUARE+2,
									g_sprites[0].y*SQUARE-SQUARE+2,
									(Bitmap *)LMemDeref(@Cloud3Moniker), 0);
		TimerSleep(6);
		EraseCloud(gstate);
		GrSetAreaMaskSys(gstate, SDM_25);
		GrDrawBitmap(gstate, g_sprites[0].x*SQUARE-SQUARE+2,
									g_sprites[0].y*SQUARE-SQUARE+2,
									(Bitmap *)LMemDeref(@Cloud3Moniker), 0);
		TimerSleep(6);       
		GrInvalRect(gstate, g_sprites[0].x*SQUARE-SQUARE+2,
								  g_sprites[0].y*SQUARE-SQUARE+2,
								  g_sprites[0].x*SQUARE+(SQUARE*2),
								  g_sprites[0].y*SQUARE+(SQUARE*2));
		MemUnlock(OptrToHandle(@Cloud1Moniker));
		}

	 if (g_vacGameStatus == STATUS_PAUSED) {
		GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0);
		GrSetFont(gstate, FID_DTC_URW_ROMAN, MakeWWFixed(36));
		MemLock(OptrToHandle(@PausedText));
		GrDrawText(gstate, 180, 115, LMemDeref(@PausedText), 0);
		GrSetTextColor(gstate, CF_INDEX, C_WHITE, 0, 0);
		GrDrawText(gstate, 177, 112, LMemDeref(@PausedText), 0);
		MemUnlock(OptrToHandle(@PausedText));
		}
	 }  /* end of active board else */

}

/***********************************************************************
 *      MSG_GAME_START_NEW_GAME for VacContentClass
 ***********************************************************************
 * SYNOPSIS:        start a new game and set up view
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacContentClass, MSG_GAME_START_NEW_GAME
{

  g_curFrame = 0;
  g_gameScore = 0;
  g_gameLives = 3;
  g_moveThisFrame = FALSE;
  @send Difficulty::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @call Score::MSG_GEN_VALUE_SET_INTEGER_VALUE(0, 0);
  @call Lives::MSG_GEN_VALUE_SET_INTEGER_VALUE(g_gameLives, 0);
  @call ControlGroup::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send PauseGame::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send ContinueGame::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send NewGame::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send NewGameButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  g_keyPressedTable[0] = 0;
  g_keyPressedTable[1] = 0;
  g_keyPressedTable[2] = 0;
  g_keyPressedTable[3] = 0;
  g_lastDirection = DIR_NONE;
  g_newDirection = DIR_NONE;

  @call oself::MSG_GAME_NEW_BOARD();

  pself->timerHandle = TimerStart(TIMER_EVENT_CONTINUAL,
    ConstructOptr(GeodeGetProcessHandle(), 0), 6,
	 MSG_GAME_NEW_FRAME, 6, &(pself->timerId));

  g_vacGameStatus = STATUS_PLAYING;
}

/***********************************************************************
 *      MSG_GAME_END_GAME for VacContentClass
 ***********************************************************************
 * SYNOPSIS:      end the game
 * PARAMETERS:   
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:  CAREFUL, EndGame object was deleted, but we still need
 *      this method! 
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacContentClass, MSG_GAME_END_GAME
{
  g_vacGameStatus = STATUS_NO_GAME;
  TimerStop(pself->timerHandle, pself->timerId);
  pself->timerHandle = 0;
  pself->timerId = 0;
  @send PauseGame::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send ContinueGame::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send NewGame::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send NewGameButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @call ControlGroup::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send Difficulty::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

  @call oself::MSG_VIS_REDRAW_ENTIRE_OBJECT();
}

/***********************************************************************
 *      MSG_GAME_PAUSE_GAME for VacContentClass
 ***********************************************************************
 * SYNOPSIS:      pause the game
 * PARAMETERS:   
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:  
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacContentClass, MSG_GAME_PAUSE_GAME
{
  g_vacGameStatus = STATUS_PAUSED;
  TimerStop(pself->timerHandle, pself->timerId);
  @send PauseGame::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send ContinueGame::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send NewGame::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send NewGameButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

  @send oself::MSG_VIS_REDRAW_ENTIRE_OBJECT();
}

/***********************************************************************
 *      MSG_GAME_CONTINUE_GAME for VacContentClass
 ***********************************************************************
 * SYNOPSIS:      continue the game
 * PARAMETERS:   
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:  resume the game from the paused state
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacContentClass, MSG_GAME_CONTINUE_GAME
{
  g_vacGameStatus = STATUS_PLAYING;
  g_wasPaused = TRUE;
  @send oself::MSG_VIS_REDRAW_ENTIRE_OBJECT();
  pself->timerHandle = TimerStart(TIMER_EVENT_CONTINUAL,
    ConstructOptr(GeodeGetProcessHandle(), 0), 6,
    MSG_GAME_NEW_FRAME, 6, &(pself->timerId));
  @send PauseGame::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send ContinueGame::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send NewGame::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  @send NewGameButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

  }

/***********************************************************************
 *      MSG_GAME_NEW_BOARD for VacContentClass
 ***********************************************************************
 * SYNOPSIS:      draw a new board
 * PARAMETERS:   
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:		a new level has started
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacContentClass, MSG_GAME_NEW_BOARD
{
  char *board1;
  word x, y, i;
  word boardOffset;
  GStateHandle gstate;


  gstate = @call oself::MSG_VIS_VUP_CREATE_GSTATE();
/* ??????? do I need to destroy this gstate ??????  */
  g_cheat = 0;

  /* initialize the vacuum */
  g_sprites[0].state = SPRITE_STATE_NORMAL;
  g_sprites[0].state_timer = 0;
  g_sprites[0].state2 = SPRITE_STATE_NORMAL;
  g_sprites[0].state2_timer = 0;
  g_sprites[0].curframe = 0;
  g_sprites[0].direction = SPRITE_DIRECTION_LEFT;
  /* initialize the bunnies */
  g_sprites[1].state = SPRITE_STATE_DEAD;
  g_sprites[2].state = SPRITE_STATE_DEAD;
  g_sprites[3].state = SPRITE_STATE_DEAD;
  g_sprites[4].state = SPRITE_STATE_DEAD;


  MemLock(OptrToHandle(@Board1));
  switch (g_level) {
	 case (1):
		board1 = LMemDeref(@Board1);
		break;
	 case (2):
		board1 = LMemDeref(@Board2);
		break;
	 case (3):
		board1 = LMemDeref(@Board3);
		break;
	 case (4):
		board1 = LMemDeref(@Board4);
		break;
	 case (5):
		board1 = LMemDeref(@Board5);
		break;
	 case (6):
		board1 = LMemDeref(@Board6);
		break;
	 case (7):
		board1 = LMemDeref(@Board7);
		break;
	 case (8):
		board1 = LMemDeref(@Board8);
		break;
	 case (9):
		board1 = LMemDeref(@Board9);
		break;
	 case (10):
		board1 = LMemDeref(@Board10);
		break;
	 }  /* end switch */
  for (boardOffset = 0; boardOffset < 13*LEVEL_WIDTH; boardOffset++) {
    g_curBoard[boardOffset] = board1[boardOffset];
  }
  MemUnlock(OptrToHandle(@Board1));

  g_dustCount = 0;
  g_bunnyCount = 0;
  boardOffset = 0;
  g_bunnyRelease = 50;
  g_vacCaught = FALSE;
  g_showCloud = FALSE;
  for (i = 0; i < MAX_SPRITES-1; i++) g_bunCaught[i] = FALSE;

  /* draw the background */
  GrSetAreaColor(gstate, CF_INDEX, C_BLACK, 0, 0);
  GrFillRect(gstate, 0, 0,
						 BOARD_WIDTH*SQUARE, BOARD_HEIGHT*SQUARE);

  for (y = 0; y < 13; y++) {
    for (x = 0; x < LEVEL_WIDTH-1; x++) {
      if (g_curBoard[boardOffset] == '*') {
		  GrSetAreaColor(gstate, CF_INDEX, C_BLUE, 0, 0);
		  GrFillRect(gstate, x*SQUARE, y*SQUARE,
						 x*SQUARE+SQUARE, y*SQUARE+SQUARE);
		  }
		else if (g_curBoard[boardOffset] == '+') {
		  g_dustCount++;
		  GrSetAreaColor(gstate, CF_INDEX, C_LIGHT_GRAY, 0, 0);
		  GrFillEllipse(gstate, x*SQUARE+8, y*SQUARE+8,
							 x*SQUARE+15, y*SQUARE+15);
		  }
		else if (g_curBoard[boardOffset] == '-') {
		  GrSetAreaColor(gstate, CF_INDEX, C_WHITE, 0, 0);
		  GrFillRect(gstate, x*SQUARE, y*SQUARE+5,
						 x*SQUARE+SQUARE, y*SQUARE+18);
		  }
		else if (g_curBoard[boardOffset] == 'V') {
		  g_vacmanX = x;
		  g_vacmanY = y;
		  g_sprites[0].x = x;
		  g_sprites[0].lastx = x;
		  g_sprites[0].startx = x;
		  g_sprites[0].y = y;
		  g_sprites[0].lasty = y;
		  g_sprites[0].starty = y;
		  g_sprites[0].state = SPRITE_STATE_NORMAL;
		  g_sprites[0].oldstate = SPRITE_STATE_NORMAL;
		  MemLock(OptrToHandle(@Jvac1lBitmap));
		  GrDrawBitmap(gstate, x*SQUARE+1, y*SQUARE+1,
							(Bitmap *)LMemDeref(@Jvac1lBitmap), 0);
		  MemUnlock(OptrToHandle(@Jvac1lBitmap));
		  g_curBoard[boardOffset] = ' ';
		  }
		else if (g_curBoard[boardOffset] == 'N') {
		  g_dustCount++;  /* NOTE - counted as a dust ball */
		  MemLock(OptrToHandle(@JbagBitmap));
		  GrDrawBitmap(gstate, x*SQUARE+1, y*SQUARE+1,
							(Bitmap *)LMemDeref(@JbagBitmap), 0);
		  MemUnlock(OptrToHandle(@JbagBitmap));
		  }
		else if ((g_curBoard[boardOffset] == 'B') || (g_curBoard[boardOffset] == 'b')){
		  if (g_bunnyCount < MAX_SPRITES-1) {
			 g_bunnyCount++;
			 g_sprites[g_bunnyCount].x = x;
			 g_sprites[g_bunnyCount].startx = x;
			 g_sprites[g_bunnyCount].lastx = x;
			 g_sprites[g_bunnyCount].y = y;
			 g_sprites[g_bunnyCount].starty = y;
			 g_sprites[g_bunnyCount].lasty = y;
			 g_sprites[g_bunnyCount].state = SPRITE_STATE_DEAD;
			 g_sprites[g_bunnyCount].oldstate = SPRITE_STATE_DEAD;
			 g_sprites[g_bunnyCount].direction = SPRITE_DIRECTION_SEEK;
			 if (g_curBoard[boardOffset] == 'b') {
            /* this means that bunny exits pen down vs up */
				g_sprites[g_bunnyCount].state2 = 1;
				}
			 else {
				g_sprites[g_bunnyCount].state2 = 0;
				}
			 MemLock(OptrToHandle(@JbunBitmap));
			 GrDrawBitmap(gstate, x*SQUARE+1, y*SQUARE+1,
							(Bitmap *)LMemDeref(@JbunBitmap), 0);
		    MemUnlock(OptrToHandle(@JbunBitmap));
			 }
		  }
      boardOffset++;
		}
    boardOffset++;
	 }

  g_bunnyLeft = g_bunnyCount;
  @call VacGameContent::MSG_VIS_REDRAW_ENTIRE_OBJECT();

}
/***********************************************************************
 *      MSG_GAME_NEW_FRAME for VacManProcessClass
 ***********************************************************************
 * SYNOPSIS:      new frame, called by the timer started in
 *						START_NEW_GAME and CONTINUE_GAME
 * PARAMETERS:
 *
 * SIDE EFFECTS:	this is the big method that makes this game go
 *
 * STRATEGY:      1) cycles thru live bunnies and moves them according to
 *							the vacuum's status
 *						2) sees if bunny met vac and responds accordingly
 *						3) fires up another bunny if time and bunnies left
 *						4) checks for vacuum movement commands & moves if appropriate
 *						5) checks on power down time and does it
 *						6) sees if vacuum sucked dust or powered up
 *						7) sees if vacuum met bunny and responds accordingly
 *						8) force a board redraw
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  DC  11/27           got lots of TimerSleeps in her for testing
 *  jfh		1/4/00		re-write to do graphics more conventionally
 *
 ***********************************************************************/
@method VacManProcessClass, MSG_GAME_NEW_FRAME
{
  word vacOffset, bunnyX, bunnyY, curBunny, i;
  Boolean anyBunnyMoved, bunnyMoved, vacMoved;


  if (g_vacGameStatus == STATUS_PLAYING) {

	 /* g_curFrame starts at 0 in new game method - the bunnies move more
	  * frequently at harder levels of play */
	 g_curFrame = (g_curFrame + 1) % g_difficultyLevel;

	 /* slow down the vacuum automatic movement to every other cycle */
	 g_moveThisFrame = !g_moveThisFrame;

	 bunnyMoved = FALSE;
	 anyBunnyMoved = FALSE;

	 if (g_curFrame == 0) {
		/* cycle thru the bunnies and move them */
		for (curBunny = 1; curBunny <= g_bunnyCount; curBunny++) {
		  if (g_sprites[curBunny].state == SPRITE_STATE_NORMAL) {
			 /* this bunny is alive */
			 bunnyMoved = FALSE;
			 bunnyX = g_sprites[curBunny].x;
			 bunnyY = g_sprites[curBunny].y;
			 if (g_sprites[0].state == SPRITE_STATE_NORMAL) {
				/* the vacuum is not powered up - bunnies attack! */
				switch (g_sprites[curBunny].direction) {
				  case (SPRITE_DIRECTION_SEEK):
					 /* check down/up */
					 if (bunnyY < g_vacmanY) {
						/* the vac is below us, can we move down? */
						if (BunnyCollide(bunnyY + 1, bunnyX, curBunny)) {
						  /* Yes, update the last position... */
						  UpdateLastPos(curBunny);
						  /* and move him */
						  g_sprites[curBunny].y ++;
						  bunnyMoved = TRUE;
						  }
						}
					 else if (bunnyY > g_vacmanY) {
						if (BunnyCollide(bunnyY - 1, bunnyX, curBunny)) {
						  UpdateLastPos(curBunny);
						  g_sprites[curBunny].y --;
						  bunnyMoved = TRUE;
						  }
						}
					 if (!bunnyMoved) {
						/* if we haven't moved down/up check right/left */
						if (bunnyX < g_vacmanX) {
						  if (BunnyCollide(bunnyY, bunnyX + 1, curBunny)) {
							 UpdateLastPos(curBunny);
							 g_sprites[curBunny].x ++;
							 bunnyMoved = TRUE;
							 }
						  }
						else if (bunnyX > g_vacmanX) {
						  if (BunnyCollide(bunnyY, bunnyX - 1, curBunny)) {
							 UpdateLastPos(curBunny);
							 g_sprites[curBunny].x --;
							 bunnyMoved = TRUE;
							 }
						  }
						}
					 if (!bunnyMoved) {
						/* if we still haven't moved we are in same row/col... */
						/* are we in the same column as the vac?  */
						if (bunnyX == g_vacmanX) {  /* yes - directly above/below  */
						  if (bunnyX == 0) {
							 /* If we're in the 0th column we CAN move right -
							  * we're at the wrap around row.
							  * NOTE: this is a board drawing restriction! */
							 UpdateLastPos(curBunny);
							 g_sprites[curBunny].x ++;
							 bunnyMoved = TRUE;
							 }
						  else if (bunnyX == (LEVEL_WIDTH - 1))  {
							 /* If we're in the 19th column we CAN move left -
							  * we're at the wrap around row.
							  * NOTE: this is a board drawing restriction! */
							 UpdateLastPos(curBunny);
							 g_sprites[curBunny].x --;
							 bunnyMoved = TRUE;
							 }
						  if (bunnyX > ((LEVEL_WIDTH - 1) >> 1)) {
							 /* if we're on the right side... */
							 g_sprites[curBunny].direction = SPRITE_DIRECTION_LEFT;
							 }
						  else {
							 /* we're on the left side... */
							 g_sprites[curBunny].direction = SPRITE_DIRECTION_RIGHT;
							 }
						  }
						/* the same row? */
						else if (bunnyY == g_vacmanY) {
						  if (bunnyY > 7) {
							 g_sprites[curBunny].direction = SPRITE_DIRECTION_UP;
							 }
						  else {
							 g_sprites[curBunny].direction = SPRITE_DIRECTION_DOWN;
							 }
						  }
						}
					 break;
				  case (SPRITE_DIRECTION_LEFT):
					 if ((bunnyY < g_vacmanY) &&
						  BunnyCollide(bunnyY + 1, bunnyX, curBunny)) {
					 UpdateLastPos(curBunny);
						g_sprites[curBunny].y ++;
						bunnyMoved = TRUE;
						g_sprites[curBunny].direction = SPRITE_DIRECTION_SEEK;
						}
					 else if ((bunnyY > g_vacmanY) &&
						  BunnyCollide(bunnyY - 1, bunnyX, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].y --;
						bunnyMoved = TRUE;
						g_sprites[curBunny].direction = SPRITE_DIRECTION_SEEK;
						}
					 else if (BunnyCollide(bunnyY, bunnyX - 1, curBunny) &&
								(bunnyX != 1)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].x --;
						bunnyMoved = TRUE;
						}
					 else {
						g_sprites[curBunny].direction = SPRITE_DIRECTION_RIGHT;
						if (BunnyCollide(bunnyY, bunnyX + 1, curBunny)) {
						  UpdateLastPos(curBunny);
						  g_sprites[curBunny].x ++;
						  bunnyMoved = TRUE;
						  }
						}
					 break;
				  case (SPRITE_DIRECTION_RIGHT):
					 if ((bunnyY < g_vacmanY) &&
						  BunnyCollide(bunnyY + 1, bunnyX, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].y ++;
						bunnyMoved = TRUE;
						g_sprites[curBunny].direction = SPRITE_DIRECTION_SEEK;
						}
					 else if ((bunnyY > g_vacmanY) &&
							BunnyCollide(bunnyY - 1, bunnyX, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].y --;
						bunnyMoved = TRUE;
						g_sprites[curBunny].direction = SPRITE_DIRECTION_SEEK;
						}
					 else if (BunnyCollide(bunnyY, bunnyX + 1, curBunny) &&
								(bunnyX != (LEVEL_WIDTH - 2))) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].x ++;
						bunnyMoved = TRUE;
						}
					 else {
						g_sprites[curBunny].direction = SPRITE_DIRECTION_LEFT;
						if (BunnyCollide(bunnyY, bunnyX - 1, curBunny)) {
						  UpdateLastPos(curBunny);
						  g_sprites[curBunny].x --;
						  bunnyMoved = TRUE;
						  }
						}
					 break;
				  case (SPRITE_DIRECTION_UP):
					 if ((bunnyX < g_vacmanX) &&
							 BunnyCollide(bunnyY, bunnyX + 1, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].x ++;
						bunnyMoved = TRUE;
						g_sprites[curBunny].direction = SPRITE_DIRECTION_SEEK;
						}
					 else if ((bunnyX > g_vacmanX) &&
						 BunnyCollide(bunnyY, bunnyX - 1, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].x --;
						bunnyMoved = TRUE;
						g_sprites[curBunny].direction = SPRITE_DIRECTION_SEEK;
						}
					 else if (BunnyCollide(bunnyY - 1, bunnyX, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].y --;
						bunnyMoved = TRUE;
						}
					 else {
						g_sprites[curBunny].direction = SPRITE_DIRECTION_DOWN;
						if (BunnyCollide(bunnyY + 1, bunnyX, curBunny)) {
						  UpdateLastPos(curBunny);
						  g_sprites[curBunny].y ++;
						  bunnyMoved = TRUE;
						  }
						}
					 break;
				  case (SPRITE_DIRECTION_DOWN):
					 if ((bunnyX < g_vacmanX) &&
							 BunnyCollide(bunnyY, bunnyX + 1, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].x ++;
						bunnyMoved = TRUE;
						g_sprites[curBunny].direction = SPRITE_DIRECTION_SEEK;
						}
					 else if ((bunnyX > g_vacmanX) &&
							BunnyCollide(bunnyY, bunnyX - 1, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].x --;
						bunnyMoved = TRUE;
						g_sprites[curBunny].direction = SPRITE_DIRECTION_SEEK;
						}
					 else if (BunnyCollide(bunnyY + 1, bunnyX, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].y ++;
						bunnyMoved = TRUE;
						}
					 else {
						g_sprites[curBunny].direction = SPRITE_DIRECTION_UP;
						if (BunnyCollide(bunnyY - 1, bunnyX, curBunny)) {
						  UpdateLastPos(curBunny);
						  g_sprites[curBunny].y --;
						  bunnyMoved = TRUE;
						  }
						}
					 break;
				  } /* end of direction switch */
				} /* end of bunny attack state if */

			 else {  /* bunnies flee! */
				/* some other vacuum state - tilted/inflated */
				if (bunnyX > g_vacmanX) {
				  if (BunnyCollide(bunnyY, bunnyX + 1, curBunny)) {
					 if (g_sprites[curBunny].x == 19) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].x = 0;
						}
					 else {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].x ++;
						}
					 }
				  bunnyMoved = TRUE;
				  }
				else if (bunnyX < g_vacmanX) {
				  if (BunnyCollide(bunnyY, bunnyX - 1, curBunny)) {
					 if (g_sprites[curBunny].x == 0) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].x = 19;
						}
					 else {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].x --;
						}
					 bunnyMoved = TRUE;
					 }
				  }
				if (!bunnyMoved) {
				  /* haven't moved yet */
				  if (bunnyY > g_vacmanY) {
					 if (BunnyCollide(bunnyY + 1, bunnyX, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].y ++;
						}
					 }
				  else if (bunnyY < g_vacmanY) {
					 if (BunnyCollide(bunnyY - 1, bunnyX, curBunny)) {
						UpdateLastPos(curBunny);
						g_sprites[curBunny].y --;
						}
					 }
				  }
				}  /* end of bunnies flee else */
			 }  /* end of bunny alive if */
		  if (bunnyMoved) anyBunnyMoved = TRUE;
		  }  /* end of cycle thru bunnies for */
		}  /* end of curframe == 0 if */

	 /* now that we've moved the bunny(s) - we'll check to see if
	  * there is a bunny/vac meeting */
	 for (curBunny = 1; curBunny <= g_bunnyCount; curBunny++) {
		if (g_sprites[curBunny].x == g_sprites[0].x &&
				g_sprites[curBunny].y == g_sprites[0].y) {
		  /* yes - a bunny met the vac. */
		  if (g_sprites[0].state == SPRITE_STATE_NORMAL) {
			 /* the bunny caught the vac :-(   */
			 g_showCloud = TRUE;
			 @call VacGameContent::MSG_VIS_REDRAW_ENTIRE_OBJECT();
			 /* put everyone back in their starting places */
			 for (i = 0; i <=4; i++) {
				UpdateLastPos(i);
				g_sprites[i].x = g_sprites[i].startx;
				g_sprites[i].y = g_sprites[i].starty;
				g_sprites[i].state = SPRITE_STATE_DEAD;
				g_sprites[i].direction = SPRITE_DIRECTION_SEEK;
				}
			 g_sprites[0].state = SPRITE_STATE_NORMAL;
			 g_sprites[0].direction = SPRITE_DIRECTION_LEFT;
			 g_bunnyLeft = g_bunnyCount;
			 g_bunnyRelease = 50;
			 g_vacmanX = g_sprites[0].x;
			 g_vacmanY = g_sprites[0].y;
			 g_gameLives--;
			 @send Lives::MSG_GEN_VALUE_SET_INTEGER_VALUE(g_gameLives, 0);
			 if (g_gameLives == 0) {
				/* the game is over */
				VacPlaySound(lose);
				@call VacGameContent::MSG_GAME_END_GAME();
				MemLock(OptrToHandle(@GameOver));
				UserStandardDialog(0, 0, 0, 0,
							LMemDeref(@GameOver),
							((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
							(GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
				MemUnlock(OptrToHandle(@GameOver));
				if (g_gameScore && g_level) {
				  @send HighScoreControl::MSG_HIGH_SCORE_ADD_SCORE((dword) g_gameScore, 0);
				  }
				g_level = 1;
				@send GameLevel::MSG_GEN_VALUE_SET_INTEGER_VALUE(1, 0);
				}
			 else {
				/* we just lost a life ... */
				g_lastDirection = DIR_NONE; /* stop the Vac */
				g_newDirection = DIR_NONE;
				VacPlaySound(caught);
				g_vacCaught = TRUE;
				@call VacGameContent::MSG_VIS_REDRAW_ENTIRE_OBJECT();
				for (i = 0; i <=4; i++) {
				  UpdateLastPos(i);
              }
				g_vacCaught = FALSE;
				}
			 return;
			 } /* end of bunny caught vac if */
		  else {
			 /* the vac caught a bunny :-)
			  * send this bunny back to the hutch */
			 @call VacGameContent::MSG_VIS_REDRAW_ENTIRE_OBJECT();
			 g_bunCaught[curBunny-1] = TRUE;
			 UpdateLastPos(curBunny);
			 g_sprites[curBunny].x = g_sprites[curBunny].startx;
			 g_sprites[curBunny].y = g_sprites[curBunny].starty;
			 g_sprites[curBunny].state = SPRITE_STATE_DEAD;
			 g_bunnyLeft++;
			 anyBunnyMoved = TRUE;
			 VacPlaySound(ateBunny);
			 g_gameScore += (75 + (25 * g_bunniesEaten));
			 g_bunniesEaten++;
			 @send Score::MSG_GEN_VALUE_SET_INTEGER_VALUE(g_gameScore, 0);
			 }
		  } /* end of bunny/vac meeting if */
		}  /* end of cycle thru bunnies for */


	 /* can we send another bunny out of the hutch? */
	 if (g_bunnyLeft) {
		/* fire up another bunny if it's time */
		if (g_bunnyRelease) {
		  g_bunnyRelease--;
		  }
		else {
		  g_bunnyRelease = 50;
		  for (curBunny = 1; curBunny <= g_bunnyCount; curBunny++) {
			 if (g_sprites[curBunny].state == SPRITE_STATE_DEAD) {
				g_sprites[curBunny].state = SPRITE_STATE_NORMAL;
				UpdateLastPos(curBunny);
				if (g_sprites[curBunny].state2) {
				  g_sprites[curBunny].y += 2;
				  }
				else {
				  g_sprites[curBunny].y -= 2;
				  }
            anyBunnyMoved = TRUE;
				g_bunnyLeft--;
				break;
				}
			 }
		  }
		}

	 /* now check for vacuum movement */
	 vacMoved = FALSE;
	 if (g_controlMethod == 0) {
		if (g_keyTable[KEY_UP] || g_keyPressedTable[KEY_UP]) {
		  g_sprites[0].direction = SPRITE_DIRECTION_UP;
		  vacOffset = (g_vacmanY - 1) * LEVEL_WIDTH + g_vacmanX;
		  if ((g_curBoard[vacOffset] != '*') &&
						 (g_curBoard[vacOffset] != '-')) {
			 g_vacmanY--;
			 UpdateLastPos(0);
			 g_sprites[0].y --;
			 vacMoved = TRUE;
			 }
		  g_keyTable[KEY_UP] = 0;
		  g_keyPressedTable[KEY_UP] = 0;
		  }
		else if (g_keyTable[KEY_DOWN] || g_keyPressedTable[KEY_DOWN]) {
		  g_sprites[0].direction = SPRITE_DIRECTION_DOWN;
		  vacOffset = (g_vacmanY + 1) * LEVEL_WIDTH + g_vacmanX;
		  if ((g_curBoard[vacOffset] != '*') &&
							(g_curBoard[vacOffset] != '-')) {
			 g_vacmanY++;
			 UpdateLastPos(0);
			 g_sprites[0].y ++;
			 vacMoved = TRUE;
			 }
		  g_keyTable[KEY_DOWN] = 0;
		  g_keyPressedTable[KEY_DOWN] = 0;
		  }
		else if (g_keyTable[KEY_LEFT] || g_keyPressedTable[KEY_LEFT]) {
		  g_sprites[0].direction = SPRITE_DIRECTION_LEFT;
		  vacOffset = g_vacmanY * LEVEL_WIDTH + (g_vacmanX - 1);
		  if ((g_curBoard[vacOffset] != '*') &&
					 (g_curBoard[vacOffset] != '-')) {
			 g_vacmanX--;
			 if (g_vacmanX == -1) {
				g_vacmanX = 19;
				UpdateLastPos(0);
				g_sprites[0].x = 19;
				}
			 else {
				UpdateLastPos(0);
				g_sprites[0].x --;
				}
			 vacMoved = TRUE;
			 }
		  g_keyTable[KEY_LEFT] = 0;
		  g_keyPressedTable[KEY_LEFT] = 0;
		  }
		else if (g_keyTable[KEY_RIGHT] || g_keyPressedTable[KEY_RIGHT]) {
		  g_sprites[0].direction = SPRITE_DIRECTION_RIGHT;
		  vacOffset = g_vacmanY * LEVEL_WIDTH + (g_vacmanX + 1);
		  if ((g_curBoard[vacOffset] != '*') &&
					(g_curBoard[vacOffset] != '-')) {
			 g_vacmanX++;
			 if (g_vacmanX == 20) {
				g_vacmanX = 0;
				UpdateLastPos(0);
				g_sprites[0].x = 0;
				}
			 else {
				UpdateLastPos(0);
				g_sprites[0].x ++;
				}
			 vacMoved = TRUE;
			 }
		  g_keyTable[KEY_RIGHT] = 0;
		  g_keyPressedTable[KEY_RIGHT] = 0;
		  }
		} /* end of manual vacuum movement if */

	 /* now for automatic movement */
	 else {
		if (g_newDirection == g_lastDirection) {
		  if (!CheckBarrier(g_lastDirection, g_curBoard)) {
			 MoveVac(g_lastDirection);
			 vacMoved = TRUE;
			 }
		  }
		else {
		  if (CheckBarrier(g_newDirection, g_curBoard))  {
			 if (!CheckBarrier(g_lastDirection, g_curBoard)) {
				MoveVac(g_lastDirection);
				vacMoved = TRUE;
				}
			 }
		  else {
			 MoveVac(g_newDirection);
			 vacMoved = TRUE;
			 g_lastDirection = g_newDirection;
			 }
		  }
		}  /* end of automatic movement else */

	 /* now power down the vacuum if appropriate */
	 if (g_sprites[0].state_timer) {
		g_sprites[0].state_timer--;
		if (g_sprites[0].state_timer == 0) {
		  if (g_sprites[0].state == SPRITE_STATE_INFLATED) {
			 g_sprites[0].state = SPRITE_STATE_TILTED;
			 g_sprites[0].oldstate = SPRITE_STATE_INFLATED;
			 g_sprites[0].state_timer = 20;
			 g_sprites[0].curframe = 1;
			 }
		  else {
			 g_sprites[0].state = SPRITE_STATE_NORMAL;
			 g_sprites[0].oldstate = SPRITE_STATE_TILTED;
			 g_sprites[0].curframe = 0;
			 }
		  }
		}

	 if (vacMoved) {
		/* check and see what happend - if anything */
		vacOffset = g_vacmanY * LEVEL_WIDTH + g_vacmanX;
		if (g_curBoard[vacOffset] == '+') {  /* we sucked up a dust ball */
		  g_curBoard[vacOffset] = ' ';
		  g_dustCount--;
		  VacPlaySound(eatPellet);
		  g_gameScore += 10;
		  @send Score::MSG_GEN_VALUE_SET_INTEGER_VALUE(g_gameScore, 0);
		  if (g_dustCount == 0) {
			 /* we sucked up all the dust balls! */
			 if (g_level == LAST_LEVEL || g_level == 0) {
				/* we've completed all 10 levels!!! */
				@call VacGameContent::MSG_GAME_END_GAME();
				MemLock(OptrToHandle(@YouWin));
				UserStandardDialog(0, 0, 0, 0,
					 LMemDeref(@YouWin),
					 ((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
					 (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
				MemUnlock(OptrToHandle(@YouWin));
				if (g_gameScore && g_level) {
				  @send HighScoreControl::MSG_HIGH_SCORE_ADD_SCORE((dword) g_gameScore, 0);
				  }
				g_level = 1;
				@send GameLevel::MSG_GEN_VALUE_SET_INTEGER_VALUE(1, 0);
				return;
				}
			 else {
				/* we advance to the next level */
				g_level++;
				@send GameLevel::MSG_GEN_VALUE_SET_INTEGER_VALUE(g_level, 0);
				@call VacGameContent::MSG_GAME_NEW_BOARD();
				}
			 } /* end of all dust balls sucked if */
		  }  /* end of sucking a dust ball if */
		else if (g_curBoard[vacOffset] == 'N') {
		  /* we've powered up!! */
		  g_dustCount--;  /* this means that you can't advance to a new level
							  * without using all the power ups */
		  g_curBoard[vacOffset] = ' ';
		  g_gameScore += 25;
		  g_bunniesEaten = 0;
		  if (g_dustCount) {
			 VacPlaySound(powerUp);
			 }
		  @send Score::MSG_GEN_VALUE_SET_INTEGER_VALUE(g_gameScore, 0);
		  g_sprites[0].state = SPRITE_STATE_INFLATED;
		  g_sprites[0].state_timer = 50;
		  g_sprites[0].state2 = SPRITE_STATE_NORMAL;
		  g_sprites[0].state2_timer = 0;
		  g_sprites[0].curframe = 2;
		  g_sprites[1].direction = SPRITE_DIRECTION_SEEK;
		  g_sprites[2].direction = SPRITE_DIRECTION_SEEK;
		  g_sprites[3].direction = SPRITE_DIRECTION_SEEK;
		  g_sprites[4].direction = SPRITE_DIRECTION_SEEK;
		  /* since a bag is treated like a ball then check for level end */
		  if (g_dustCount == 0) {
			 if (g_level == LAST_LEVEL || g_level == 0) {
				@call VacGameContent::MSG_GAME_END_GAME();
				MemLock(OptrToHandle(@YouWin));
				UserStandardDialog(0, 0, 0, 0,
							 LMemDeref(@YouWin),
							 ((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
							 (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
				MemUnlock(OptrToHandle(@YouWin));
				if (g_gameScore && g_level) {
				  @send HighScoreControl::MSG_HIGH_SCORE_ADD_SCORE((dword) g_gameScore, 0);
				  }
				g_level = 1;
				@send GameLevel::MSG_GEN_VALUE_SET_INTEGER_VALUE(1, 0);
				return;
				}
			 else {
				g_level++;
				@send GameLevel::MSG_GEN_VALUE_SET_INTEGER_VALUE(g_level, 0);
				@call VacGameContent::MSG_GAME_NEW_BOARD();
				}
			 } /* end of level end if */
		  }  /* end of power up else */
		}  /* end of vacuum moved if */

	 /* checking thru bunnies again - we did this after the bunnies were moved
	  * and now we do it again after the vacuum may have moved */
	 for (curBunny = 1; curBunny <= g_bunnyCount; curBunny++) {
		if (g_sprites[curBunny].x == g_sprites[0].x &&
						g_sprites[curBunny].y == g_sprites[0].y) {
		  if (g_sprites[0].state == SPRITE_STATE_NORMAL) {
			 /* bunny caught vac :-( */
			 g_showCloud = TRUE;
			 @call VacGameContent::MSG_VIS_REDRAW_ENTIRE_OBJECT();
			 for (i = 0; i <=4; i++) {
 				UpdateLastPos(i);
				g_sprites[i].x = g_sprites[i].startx;
				g_sprites[i].y = g_sprites[i].starty;
				g_sprites[i].state = SPRITE_STATE_DEAD;
				g_sprites[i].direction = SPRITE_DIRECTION_SEEK;
				}                            
			 g_sprites[0].state = SPRITE_STATE_NORMAL;
			 g_sprites[0].direction = SPRITE_DIRECTION_LEFT;
			 g_bunnyLeft = g_bunnyCount;
			 g_bunnyRelease = 50;
			 g_vacmanX = g_sprites[0].x;
			 g_vacmanY = g_sprites[0].y;
			 g_gameLives--;
			 @send Lives::MSG_GEN_VALUE_SET_INTEGER_VALUE(g_gameLives, 0);
			 if (g_gameLives == 0) {
				VacPlaySound(lose);
				@call VacGameContent::MSG_GAME_END_GAME();
				MemLock(OptrToHandle(@GameOver));
				UserStandardDialog(0, 0, 0, 0,
						  LMemDeref(@GameOver),
						  ((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
						  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
				MemUnlock(OptrToHandle(@GameOver));
				if (g_gameScore && g_level) {
				  @send HighScoreControl::MSG_HIGH_SCORE_ADD_SCORE((dword) g_gameScore, 0);
				  }
				g_level = 1;
				@send GameLevel::MSG_GEN_VALUE_SET_INTEGER_VALUE(1, 0);
				}
			 else {
				g_lastDirection = DIR_NONE;  /* stop the Vac */
				g_newDirection = DIR_NONE;
				VacPlaySound(caught);
				g_vacCaught = TRUE;
				@call VacGameContent::MSG_VIS_REDRAW_ENTIRE_OBJECT();
				for (i = 0; i <=4; i++) {
				  UpdateLastPos(i);
				  }
				g_vacCaught = FALSE;
				}
			 return;
			 }
		  else {
			 /* vac caught bunny */
			 @call VacGameContent::MSG_VIS_REDRAW_ENTIRE_OBJECT();
			 g_bunCaught[curBunny-1] = TRUE;
			 UpdateLastPos(curBunny);
			 g_sprites[curBunny].x = g_sprites[curBunny].startx;
			 g_sprites[curBunny].y = g_sprites[curBunny].starty;
			 g_sprites[curBunny].state = SPRITE_STATE_DEAD;
			 g_bunnyLeft++;
			 VacPlaySound(ateBunny);
			 g_gameScore += (75 + (25 * g_bunniesEaten));
			 g_bunniesEaten++;
			 @send Score::MSG_GEN_VALUE_SET_INTEGER_VALUE(g_gameScore, 0);
			 }
		  } /* end of bunny/vac meeting if */
		}  /* end of loop thru bunnies for */

    /* redraw only if something moved */
	 if (vacMoved || anyBunnyMoved)
	    @call VacGameContent::MSG_VIS_REDRAW_ENTIRE_OBJECT();

  }  /* end of status playing if */

}

/***********************************************************************
 *      MSG_META_KBD_CHAR for VacApplicationClass
 ***********************************************************************
 * SYNOPSIS:     
 * PARAMETERS:   
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY: 
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  
 *
 ***********************************************************************/
@method VacApplicationClass, MSG_META_KBD_CHAR
{

  /* if we're not playing then fugeddaboudit */
  if (g_vacGameStatus != STATUS_PLAYING) {
	 @callsuper();
	 }

  /* check for the 'cheat' keys if we're playing
   * cheat is set to 0 on a new board */
  if (g_vacGameStatus == STATUS_PLAYING) {
	 if (flags & CF_FIRST_PRESS) {
		if (character == '=') {
		  if (g_cheatIndex == 1) {
			 g_cheat = (g_cheat + 1) % 7;
			 }
		  else {
			 g_cheat = 1;
			 g_cheatIndex = 1;
			 }
		  if (g_cheat == 0) {
			 g_level++;
			 if (g_level > LAST_LEVEL) {
				g_level = 1;
				}
			 @send GameLevel::MSG_GEN_VALUE_SET_INTEGER_VALUE(g_level, 0);
			 @call VacGameContent::MSG_GAME_NEW_BOARD();
			 }
		  }
		else if (character == ' ') {
		  if (g_cheatIndex == 2) {
			 g_cheat = (g_cheat + 1) % 7;
			 }
		  else {
			 g_cheat = 1;
			 g_cheatIndex = 2;
			 }
		  if (g_cheat == 0) {
			 g_sprites[0].state = SPRITE_STATE_INFLATED;
			 g_sprites[0].state_timer = 50;
			 g_sprites[0].curframe = 2;
			 }
		  }
		else {
		  g_cheat = 0;
		  }
		}
	 }

  /* ckeck for vac movement keys */
  if (flags & CF_FIRST_PRESS) {
	 if ((character & 0xFF) == VC_UP) {
		if (g_controlMethod == 0) {
		  g_keyTable[KEY_UP] = -1;
//		  g_keyPressedTable[KEY_UP] = -1;
		  }
		else {
		  g_newDirection = DIR_UP;
		  if (g_lastDirection == DIR_NONE) {
			 g_lastDirection = DIR_UP; /* start condition */
			 }
		  }
		}
	 else if ((character & 0xFF) == VC_DOWN) {
		if (g_controlMethod == 0) {
		  g_keyTable[KEY_DOWN] = -1;
//		  g_keyPressedTable[KEY_DOWN] = -1;
		  }
		else {
		  g_newDirection = DIR_DOWN;
		  if (g_lastDirection == DIR_NONE) {
			 g_lastDirection = DIR_DOWN; /* start condition */
			 }
		  }
		}
    else if ((character & 0xFF) == VC_LEFT) {
      if (g_controlMethod == 0) {
		  g_keyTable[KEY_LEFT] = -1;
//		  g_keyPressedTable[KEY_LEFT] = -1;
		  }
      else {
		  g_newDirection = DIR_LEFT;
		  if (g_lastDirection == DIR_NONE) {
			 g_lastDirection = DIR_LEFT; /* start condition */
			 }
		  }
		}
    else if ((character & 0xFF) == VC_RIGHT) {
      if (g_controlMethod == 0) {
		  g_keyTable[KEY_RIGHT] = -1;
//		  g_keyPressedTable[KEY_RIGHT] = -1;
		  }
      else {
		  g_newDirection = DIR_RIGHT;
		  if (g_lastDirection == DIR_NONE) {
			 g_lastDirection = DIR_RIGHT; /* start condition */
			 }
		  }
		}
    else {
      if (g_vacGameStatus == STATUS_PLAYING) {
		  @callsuper();
		  }
		}
	 }

  /* stops a repeating key thing */
/*  else if ((g_controlMethod == 0) && (flags & CF_RELEASE)) {
	 if ((character & 0xFF) == VC_UP) {
		g_keyTable[KEY_UP] = 0;
		}
	 else if ((character & 0xFF) == VC_DOWN) {
		g_keyTable[KEY_DOWN] = 0;
		}
	 else if ((character & 0xFF) == VC_LEFT) {
		g_keyTable[KEY_LEFT] = 0;
		}
	 else if ((character & 0xFF) == VC_RIGHT) {
		g_keyTable[KEY_RIGHT] = 0;
      }
	 else {
		if (g_vacGameStatus == STATUS_PLAYING) {
		  @callsuper();
		  }
		}
	 }  */

}

/***********************************************************************
 *      MoveVac
 ***********************************************************************
 * SYNOPSIS:      called by NEW_FRAME method
 * PARAMETERS:
 *
 * SIDE EFFECTS:    ONE OF TWO NEW ROUTINES TO KEEP VAC MOVING
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  jfh                 automatic movement
 *
 ***********************************************************************/
void MoveVac(word whichWay)
{
  if (!g_moveThisFrame)
    return;

  switch (whichWay)  {
  case DIR_UP:
	 g_sprites[0].direction = SPRITE_DIRECTION_UP;
	 g_vacmanY--;
	 UpdateLastPos(0);
	 g_sprites[0].y --;
    break;
  case DIR_DOWN:
    g_sprites[0].direction = SPRITE_DIRECTION_DOWN;
    g_vacmanY++;
	 UpdateLastPos(0);
	 g_sprites[0].y ++;
	 break;
  case DIR_LEFT:
    g_sprites[0].direction = SPRITE_DIRECTION_LEFT;
    g_vacmanX--;
    if (g_vacmanX == -1) {
      g_vacmanX = 19;
	   UpdateLastPos(0);
		g_sprites[0].x = 19;
	 }
    else {
		UpdateLastPos(0);
		g_sprites[0].x --;
	 }
    break;
  case DIR_RIGHT:
    g_sprites[0].direction = SPRITE_DIRECTION_RIGHT;
    g_vacmanX++;
    if (g_vacmanX == 20) {
      g_vacmanX = 0;
		UpdateLastPos(0);
		g_sprites[0].x = 0;
	 }
    else {
		UpdateLastPos(0);
		g_sprites[0].x ++;
	 }
    break;
  } /* end switch */

}  /* end of MoveVac */



/***********************************************************************
 *      CheckBarrier
 ***********************************************************************
 * SYNOPSIS:      called by NEW_FRAME method
 * PARAMETERS:   
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY: 
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  jfh                 automatic movement
 *
 ***********************************************************************/
Boolean CheckBarrier(word whichWay, char* theBoard)
{
  Boolean barrier = TRUE;
  word direction;

  switch (whichWay)  {
  case DIR_UP:
    direction = (g_vacmanY - 1) * LEVEL_WIDTH + g_vacmanX;
    break;
  case DIR_DOWN:
    direction = (g_vacmanY + 1) * LEVEL_WIDTH + g_vacmanX;
    break;
  case DIR_LEFT:
    direction = g_vacmanY * LEVEL_WIDTH + (g_vacmanX - 1);
    break;
  case DIR_RIGHT:
	 direction = g_vacmanY * LEVEL_WIDTH + (g_vacmanX + 1);
    break;
  } /* end switch */

  if ((theBoard[direction] != '*') && (theBoard[direction] != '-')) {
    barrier = FALSE;
  }

  return(barrier);
}   /* end of CheckBarrier */


/***********************************************************************
 *      BunnyCollide
 ***********************************************************************
 * SYNOPSIS:      called by NEW_FRAME method
 * PARAMETERS:
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:      this returns TRUE if it is OK for the bunny to
 *						move in the tested direction
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *
 *
 ***********************************************************************/
Boolean BunnyCollide(word y, word x, word curbunny) {
  word count;

  if ((g_curBoard[y * LEVEL_WIDTH + x] != '*') &&
		(g_curBoard[y * LEVEL_WIDTH + x] != '-')) {
	 for (count = 1; count <= g_bunnyCount; count++) {
		if (count != curbunny) {
		  if ((g_sprites[count].x == x) &&
						  (g_sprites[count].y == y)) {
			 return(FALSE);
			 }
		  }
		}
	 }
  else {
	 return(FALSE);
    }

  return(TRUE);
}

/***********************************************************************
 *      UpdateLastPos
 ***********************************************************************
 * SYNOPSIS:      called by NEW_FRAME method
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:      this moves current x/y to last x/y
 *						for passed sprite
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  jfh		1/6/00		initial
 *
 ***********************************************************************/
void UpdateLastPos(word curSprite)
{

  g_sprites[curSprite].lastx = g_sprites[curSprite].x;
  g_sprites[curSprite].lasty = g_sprites[curSprite].y;

}

/***********************************************************************
 *      VacPlaySound
 ***********************************************************************
 * SYNOPSIS:
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  jfh		1/6/00		initial
 *
 ***********************************************************************/
void VacPlaySound(MemHandle soundHandle)
{
	word 		tempo = 8;

	if (g_sound == SOUND_SYSTEM)
	   /* this routine abides by syst sound setting */
	   UserStandardSound(SST_CUSTOM_SOUND, soundHandle, 1);
	else
		if (g_sound == SOUND_OFF)
			return;
	else
	{
		 /* this routine doesn't check syst sound setting -
		  * but we need to supply the tempo */
		 SoundPlayMusic(soundHandle, SP_GAME, tempo, EOSF_UNLOCK);
	}
}


